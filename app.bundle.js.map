{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/vector-3d.ts","webpack:///./src/matrix-3d.ts","webpack:///./src/app.ts","webpack:///./src/webgl.ts","webpack:///./src/points-3d-renderer.ts","webpack:///./src/invertible-transforms-3d.ts","webpack:///./src/shapes.ts","webpack:///./src/points-3d.ts","webpack:///./src/screen-space.ts","webpack:///./src/checkable-value.ts","webpack:///./src/ray-3d.ts","webpack:///./src/intersections.ts","webpack:///./src/get-element.ts","webpack:///./src/keyboard-map.ts","webpack:///./src/simple-vertex-shader.glsl","webpack:///./src/z-buffer-fragment-shader.glsl"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Vector3D","[object Object]","x","y","z","w","this","v","len","Math","sqrt","vector_3d_1","IDENTITY","Matrix3D","values","valueAt","Float32Array","row","column","fromVectorOrCoords","multiply","undefined","radians","cos","sin","m2","col1","transformVector","col2","col3","col4","f","map","options","near","far","left","right","top","bottom","width","height","depth","doubleNear","points","col","webgl_1","points_3d_renderer_1","matrix_3d_1","invertible_transforms_3d_1","shapes_1","screen_space_1","checkable_value_1","ray_3d_1","intersections_1","get_element_1","keyboard_map_1","simpleVertexShaderSrc","zBufferFragmentShaderSrc","Spaceship","state","colliderScale","transform","rotateZ","orbitTheta","translate","distanceFromCenter","scale","rotateY","shipTheta","props","random","orbitThetaVelocity","shipThetaVelocity","colliderRadius","ray","getRaySphereIntersection","center","Scene","cameraRotation","spaceships","ship","update","filter","doesRayIntersect","spaceshipCount","push","createRandom","window","addEventListener","canvas","getElement","ui","showColliders","pause","keyMap","KeyboardMap","setCheckboxToggler","buildUI","gl","getContext","Error","program","GlProgram","super","GlUniformMatrix3D","positionAttributeLocation","getAttribLocation","spaceshipRenderer","Points3DRenderer","makeSpaceship","groundRenderer","makeGround","circleRenderer","makeCircle","perspective","baseProjectionTransform","perspectiveProjection","scene","screenClick","CheckableValue","onclick","e","checked","set","offsetX","offsetY","console","log","render","cameraTransform","InvertibleTransforms3D","viewTransform","inverse","projectionTransform","viewport","enable","DEPTH_TEST","clearColor","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","activate","renderer","setupForDrawing","draw","LINES","forEach","spaceship","baseTransform","uniform","rotateX","PI","WebGLRenderingContext","LINE_LOOP","drawCollider","getColliderTransform","check","coords","shootRay","cameraPosition","matrix","getCameraPosition","screenPointInWorld","screenCoordsToWorld","Ray3D","fromTo","makeRayPoints","requestAnimationFrame","createShader","type","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","msg","getShaderInfoLog","deleteShader","loc","vertexShaderSrc","fragmentShaderSrc","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","useProgram","GlUniformBase","location","getUniformLocation","GlUniformVector","uniform4fv","GlUniformFloat","uniform1f","uniformMatrix4fv","toFloat32Array","buffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","enableVertexAttribArray","FLOAT","vertexAttribPointer","primitiveType","TRIANGLES","count","length","drawArrays","ops","op","vector","addOp","times","inverseOp","points_3d_1","mirror","leftHalf","transformPoints","Points3D","fromArray","concat","xzStart","size","pointsPerAxis","xPart","zPart","partInc","segments","point","origin","increment","direction","plus","start","array","result","arrIndex","combined","fn","numPoints","pointArray","Array","pointRelativeToCamera","xPct","yPct","screenCoordsToEye","lastCheckedValue","cb","normalize","from","to","minus","radius","originMinusCenter","b","dot","bSquaredMinusC","closestT","sort","a","pointAlong","tagName","selector","parent","document","finalSelector","node","querySelector","mapping","Map","body","handleEvent","el","kbd","createElement","textContent","appendChild","createTextNode","handler","toLowerCase","labelNode","addKbdElement","checkboxToggler","parentNode"],"mappings":"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","file":"app.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","/**\n * A three-dimensional vector. Note that it actually has\n * four elements because we use a homogeneous coordinate\n * system.\n */\nexport class Vector3D {\n  constructor(\n    readonly x: number = 0,\n    readonly y: number = 0,\n    readonly z: number = 0,\n    readonly w: number = 1.0\n  ) {}\n\n  perspectiveDivide(): Vector3D {\n    const { x, y, z, w } = this;\n    return new Vector3D(x / w, y / w, z / w);\n  }\n\n  minus(v: Vector3D): Vector3D {\n    const { x, y, z, w } = this;\n    return new Vector3D(x - v.x, y - v.y, z - v.z, w);\n  }\n\n  plus(v: Vector3D): Vector3D {\n    const { x, y, z, w } = this;\n    return new Vector3D(x + v.x, y + v.y, z + v.z, w);\n  }\n\n  times(n: number): Vector3D {\n    const { x, y, z, w } = this;\n    return new Vector3D(x * n, y * n, z * n, w);\n  }\n\n  dot(v: Vector3D): number {\n    const { x, y, z, w } = this;\n\n    return x * v.x + y * v.y + z * v.z;\n  }\n\n  normalize(): Vector3D {\n    const { x, y, z, w } = this;\n    const len = Math.sqrt(x * x + y * y + z * z);\n    return new Vector3D(x / len, y / len, z / len, w);\n  }\n\n  /**\n   * A helper to convert either a vector or a sequence of coordinates\n   * into a vector.\n   */\n  static fromVectorOrCoords(x: Vector3D | number, y?: number, z?: number): Vector3D {\n    z = x instanceof Vector3D ? x.z : z || 0;\n    y = x instanceof Vector3D ? x.y : y || 0;\n    x = x instanceof Vector3D ? x.x : x;\n    return new Vector3D(x, y, z);\n  }\n}","import { Vector3D } from \"./vector-3d\";\nimport { Points3D } from \"./points-3d\";\n\ntype Column = 1|2|3|4;\ntype Row = 1|2|3|4;\n\n/**\n * A 4x4 matrix represented as\n * a two-dimensional array in\n * row-major order.\n */\ntype Matrix3DTuple = [\n  [number, number, number, number],\n  [number, number, number, number],\n  [number, number, number, number],\n  [number, number, number, number]\n];\n\nexport type PerspectiveOptions = {\n  left: number;\n  right: number;\n  top: number;\n  bottom: number;\n  near: number;\n  far: number;\n};\n\nconst IDENTITY: Matrix3DTuple = [\n  [1, 0, 0, 0],\n  [0, 1, 0, 0],\n  [0, 0, 1, 0],\n  [0, 0, 0, 1]\n];\n\n/**\n * A three-dimensional matrix. Note that it ultimately represents a 4x4\n * matrix because we use homogeneous coordinates.\n */\nexport class Matrix3D {\n  constructor(readonly values: Matrix3DTuple = IDENTITY) {\n    this.valueAt = this.valueAt.bind(this);\n  }\n\n  /**\n   * Convert the matrix into a Float32Array in column-major order\n   * (the layout that GLSL expects).\n   */\n  toFloat32Array(): Float32Array {\n    const m = this.valueAt;\n    return new Float32Array([\n      m(1, 1), m(2, 1), m(3, 1), m(4, 1),\n      m(1, 2), m(2, 2), m(3, 2), m(4, 2),\n      m(1, 3), m(2, 3), m(3, 3), m(4, 3),\n      m(1, 4), m(2, 4), m(3, 4), m(4, 4),\n    ]);\n  }\n\n  valueAt(row: Row, column: Column): number {\n    return this.values[row - 1][column - 1];\n  }\n\n  translate(v: Vector3D): Matrix3D;\n  translate(x: number, y: number, z: number): Matrix3D;\n\n  translate(x: Vector3D|number, y?: number, z?: number): Matrix3D {\n    const v = Vector3D.fromVectorOrCoords(x, y, z);\n\n    return this.multiply(new Matrix3D([\n      [1, 0, 0, v.x],\n      [0, 1, 0, v.y],\n      [0, 0, 1, v.z],\n      [0, 0, 0,   1]\n    ]));\n  }\n\n  scale(x: number, y?: number, z?: number): Matrix3D {\n    if (y === undefined) {\n      y = x;\n    }\n    if (z === undefined) {\n      z = y;\n    }\n    return this.multiply(new Matrix3D([\n      [x, 0, 0, 0],\n      [0, y, 0, 0],\n      [0, 0, z, 0],\n      [0, 0, 0, 1]\n    ]));\n  }\n\n  /** Rotate counter-clockwise around the X axis. */\n  rotateX(radians: number) {\n    // Deriving this requires the trigonometric identities for angle sums:\n    //\n    //   https://en.wikipedia.org/wiki/List_of_trigonometric_identities\n    //\n    // That said, I think an alternative approach is to think of rotation\n    // as transformation of basis vectors via matrix multiplication,\n    // which simplifies things conceptually.\n    const c = Math.cos(radians);\n    const s = Math.sin(radians);\n    return this.multiply(new Matrix3D([\n      [1,  0, 0, 0],\n      [0,  c, s, 0],\n      [0, -s, c, 0],\n      [0,  0, 0, 1]\n    ]));\n  }\n\n  /** Rotate counter-clockwise around the Y axis. */\n  rotateY(radians: number) {\n    const c = Math.cos(radians);\n    const s = Math.sin(radians);\n    return this.multiply(new Matrix3D([\n      [c, 0, -s, 0],\n      [0, 1,  0, 0],\n      [s, 0,  c, 0],\n      [0, 0,  0, 1]\n    ]));\n  }\n\n  /** Rotate counter-clockwise around the Z axis. */\n  rotateZ(radians: number) {\n    const c = Math.cos(radians);\n    const s = Math.sin(radians);\n    return this.multiply(new Matrix3D([\n      [c, -s, 0, 0],\n      [s,  c, 0, 0],\n      [0,  0, 1, 0],\n      [0,  0, 0, 1]\n    ]));\n  }\n\n  multiply(m2: Matrix3D): Matrix3D {\n    // Conceptualy, it's easiest to think of matrix multiplication\n    // as a transformation of a coordinate system's basis\n    // vectors:\n    //\n    //   http://www.3blue1brown.com/essence-of-linear-algebra-page/\n    //\n    // This isn't particularly efficient code, but hopefully\n    // it is readable.\n    const col1 = this.transformVector(m2.column(1));\n    const col2 = this.transformVector(m2.column(2));\n    const col3 = this.transformVector(m2.column(3));\n    const col4 = this.transformVector(m2.column(4));\n    return new Matrix3D([\n      [col1.x, col2.x, col3.x, col4.x],\n      [col1.y, col2.y, col3.y, col4.y],\n      [col1.z, col2.z, col3.z, col4.z],\n      [col1.w, col2.w, col3.w, col4.w],\n    ]);\n  }\n\n  /**\n   * Apply the given function to every element of the matrix, returning\n   * a new one.\n   */\n  map(f: (value: number) => number): Matrix3D {\n    return new Matrix3D(this.values.map(row => row.map(f)) as Matrix3DTuple);\n  }\n\n  /**\n   * Multiply all elements of the matrix by the given constant,\n   * returning a new matrix.\n   */\n  multiplyByConstant(n: number): Matrix3D {\n    return this.map(value => value * n);\n  }\n\n  /**\n   * Create a matrix that transforms eye coordinates into clip\n   * coordinates.\n   * \n   * Note that clip coordinates will likely have a w-component\n   * that is not 1; the GPU will perform a perspective divide\n   * after the vertex shader to convert the clip coordinates\n   * into normalized device coordinates (NDC).\n   * \n   * Note also that the near and far parameters must be\n   * specified as positive numbers, as the clip coordinates\n   * use a left-handed coordinate system, while the\n   * eye coordinates use a right-handed coordinate system,\n   * and the projection matrix will convert between the\n   * two.\n   * \n   * For more details, as well as an excellent derivation\n   * of all the math behind all this, see:\n   * \n   *   http://www.songho.ca/opengl/gl_projectionmatrix.html#perspective\n   */\n  static perspectiveProjection(options: PerspectiveOptions): Matrix3D {\n    const { near, far, left, right, top, bottom } = options;\n    const width = right - left;\n    const height = top - bottom;\n    const depth = far - near;\n    const doubleNear = 2 * near;\n    return new Matrix3D([\n      [doubleNear / width, 0, (right + left) / width, 0],\n      [0, doubleNear / height, (top + bottom) / height, 0],\n      [0, 0, -(far + near) / depth, -2 * far * near / depth],\n      [0, 0, -1, 0]\n    ]);\n  }\n\n  transformPoints(points: Points3D): Points3D {\n    return points.map(v => this.transformVector(v));\n  }\n\n  transformVector(v: Vector3D): Vector3D {\n    const m = this.valueAt;\n    return new Vector3D(\n      m(1, 1) * v.x + m(1, 2) * v.y + m(1, 3) * v.z + m(1, 4) * v.w,\n      m(2, 1) * v.x + m(2, 2) * v.y + m(2, 3) * v.z + m(2, 4) * v.w,\n      m(3, 1) * v.x + m(3, 2) * v.y + m(3, 3) * v.z + m(3, 4) * v.w,\n      m(4, 1) * v.x + m(4, 2) * v.y + m(4, 3) * v.z + m(4, 4) * v.w,\n    );\n  }\n\n  column(col: Column): Vector3D {\n    const m = this.valueAt;\n    return new Vector3D(\n      m(1, col),\n      m(2, col),\n      m(3, col),\n      m(4, col)\n    );\n  }\n}\n","import { GlProgram, getAttribLocation, GlUniformMatrix3D } from \"./webgl\";\nimport { Points3DRenderer, Points3DRendererProgram } from \"./points-3d-renderer\";\nimport { Matrix3D, PerspectiveOptions } from \"./matrix-3d\";\nimport { Vector3D } from \"./vector-3d\";\nimport { InvertibleTransforms3D } from \"./invertible-transforms-3d\";\nimport { makeSpaceship, makeGround, makeRayPoints, makeCircle } from \"./shapes\";\nimport { Point2D, screenCoordsToWorld, Dimensions2D } from \"./screen-space\";\nimport { CheckableValue } from \"./checkable-value\";\nimport { Ray3D } from \"./ray-3d\";\nimport { getRaySphereIntersection } from \"./intersections\";\nimport { getElement } from \"./get-element\";\nimport { KeyboardMap } from \"./keyboard-map\";\nimport { Points3D } from \"./points-3d\";\n\nconst simpleVertexShaderSrc = require(\"./simple-vertex-shader.glsl\") as string;\nconst zBufferFragmentShaderSrc = require(\"./z-buffer-fragment-shader.glsl\") as string;\n\nclass SimpleGlProgram extends GlProgram {\n  readonly transform: GlUniformMatrix3D;\n  readonly positionAttributeLocation: number;\n\n  constructor(gl: WebGLRenderingContext) {\n    super(gl, simpleVertexShaderSrc, zBufferFragmentShaderSrc);\n    this.transform = new GlUniformMatrix3D(this, 'u_transform');\n    this.positionAttributeLocation = getAttribLocation(gl, this.program, 'a_position');\n  }\n}\n\ntype SpaceshipState = {\n  orbitTheta: number;\n  orbitThetaVelocity: number;\n  distanceFromCenter: number;\n  scale: number;\n  shipTheta: number;\n  shipThetaVelocity: number;\n  z: number;\n};\n\nclass Spaceship {\n  readonly state: Readonly<SpaceshipState>;\n  readonly transform: Readonly<Matrix3D>;\n  private readonly colliderScale = 0.5;\n\n  constructor(state: SpaceshipState) {\n    this.state = state;\n\n    const transform = new Matrix3D()\n      .rotateZ(state.orbitTheta)\n      .translate(state.distanceFromCenter, 0, state.z)\n      .scale(state.scale)\n      .rotateY(state.shipTheta);\n\n    this.transform = transform;\n  }\n\n  static createRandom(props: Partial<SpaceshipState>) {\n    return new Spaceship({\n      orbitTheta: Math.random(),\n      orbitThetaVelocity: Math.random() * 0.01,\n      distanceFromCenter: Math.random(),\n      scale: 0.5,\n      shipTheta: Math.random(),\n      shipThetaVelocity: Math.random() * 0.05,\n      z: Math.random(),\n      ...props\n    });\n  }\n\n  get colliderRadius(): number {\n    return this.state.scale * this.colliderScale;\n  }\n\n  getColliderTransform(): Matrix3D {\n    return this.transform.scale(this.colliderScale);\n  }\n\n  center(): Vector3D {\n    return this.transform.transformVector(new Vector3D());\n  }\n\n  doesRayIntersect(ray: Ray3D): boolean {\n    return getRaySphereIntersection(ray, this.center(), this.colliderRadius) !== null;\n  }\n\n  update(): Spaceship {\n    const { state } = this;\n    return new Spaceship({\n      ...state,\n      orbitTheta: state.orbitTheta + state.orbitThetaVelocity,\n      shipTheta: state.shipTheta + state.shipThetaVelocity,\n    });\n  }\n};\n\nfunction getCameraPosition(cameraTransform: InvertibleTransforms3D): Vector3D {\n  return cameraTransform.matrix.transformVector(new Vector3D());\n}\n\nfunction buildUI() {\n  const showColliders = getElement('input', '#show-colliders');\n  const pause = getElement('input', '#pause');\n  const keyMap = new KeyboardMap();\n\n  keyMap.setCheckboxToggler('c', showColliders);\n  keyMap.setCheckboxToggler('p', pause);\n\n  return {\n    showColliders,\n    pause\n  };\n}\n\nfunction drawCollider(baseTransform: Matrix3D, uniform: GlUniformMatrix3D, renderer: Points3DRenderer) {\n  const transforms = [\n    baseTransform,\n    baseTransform.rotateX(Math.PI / 2),\n    baseTransform.rotateY(Math.PI / 2)\n  ];\n\n  transforms.forEach(transform => {\n    uniform.set(transform);\n    renderer.draw(WebGLRenderingContext.LINE_LOOP);\n  });\n}\n\nclass CameraRay {\n  readonly ray: Ray3D;\n  readonly points: Points3D;\n  readonly renderer: Points3DRenderer;\n\n  constructor(options: {\n    program: Points3DRendererProgram,\n    cameraTransform: InvertibleTransforms3D,\n    canvas: Dimensions2D,\n    coords: Point2D,\n    perspective: PerspectiveOptions,\n  }) {\n    const cameraPosition = getCameraPosition(options.cameraTransform);\n    const screenPointInWorld = screenCoordsToWorld(\n      options.canvas,\n      options.coords,\n      options.perspective,\n      options.cameraTransform.matrix\n    );\n    this.ray = Ray3D.fromTo(cameraPosition, screenPointInWorld);\n    this.points = makeRayPoints(this.ray);\n    this.renderer = new Points3DRenderer(options.program, this.points);\n  }\n}\n\ntype SceneState = {\n  spaceships: Spaceship[];\n  cameraRotation: number;\n  ray?: CameraRay;\n};\n\nclass Scene {\n  constructor(readonly state: Readonly<SceneState>) {\n  }\n\n  update(): Scene {\n    const { state } = this;\n    return new Scene({\n      ...state,\n      cameraRotation: state.cameraRotation + 0.001,\n      spaceships: state.spaceships.map(ship => ship.update())\n    });\n  }\n\n  shootRay(ray: CameraRay): Scene {\n    const { state } = this;\n    return new Scene({\n      ...state,\n      spaceships: state.spaceships.filter(s => !s.doesRayIntersect(ray.ray)),\n      ray\n    });\n  }\n\n  static createRandom(spaceshipCount: number = 30) {\n    const spaceships: Spaceship[] = [];\n\n    for (let i = 0; i < spaceshipCount; i++) {\n      spaceships.push(Spaceship.createRandom({\n        z: -1 + ((i / spaceshipCount) * 2)\n      }));\n    }\n\n    return new Scene({\n      spaceships,\n      cameraRotation: 0,\n    });\n  }\n};\n\nwindow.addEventListener('DOMContentLoaded', () => {\n  const canvas = getElement('canvas', '#canvas');\n  const ui = buildUI();\n  const gl = canvas.getContext('webgl');\n\n  if (!gl) throw new Error(\"webgl is not supported on this browser!\");\n\n  const program = new SimpleGlProgram(gl);\n  const spaceshipRenderer = new Points3DRenderer(program, makeSpaceship());\n  const groundRenderer = new Points3DRenderer(program, makeGround());\n  const circleRenderer = new Points3DRenderer(program, makeCircle());\n  const perspective: PerspectiveOptions = {\n    top: 1,\n    bottom: -1,\n    right: 1,\n    left: -1,\n    near: 1,\n    far: 3\n  };\n  const baseProjectionTransform = Matrix3D.perspectiveProjection(perspective);\n  let scene = Scene.createRandom();\n  let screenClick = new CheckableValue<Point2D>();\n\n  canvas.onclick = (e) => {\n    if (ui.pause.checked) return;\n    screenClick.set({x: e.offsetX, y: e.offsetY});\n  };\n\n  console.log(\"Initialization successful!\");\n\n  const render = () => {\n    const cameraTransform = new InvertibleTransforms3D()\n      .rotateY(scene.state.cameraRotation)\n      .translate(0, 0, 2.25);\n    const viewTransform = cameraTransform.inverse();\n    const projectionTransform = baseProjectionTransform.multiply(viewTransform);\n\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n    gl.enable(gl.DEPTH_TEST);\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    program.activate();\n\n    if (scene.state.ray) {\n      scene.state.ray.renderer.setupForDrawing();\n      program.transform.set(projectionTransform);\n      scene.state.ray.renderer.draw(gl.LINES);\n    }\n\n    groundRenderer.setupForDrawing();\n    program.transform.set(projectionTransform);\n    groundRenderer.draw(gl.LINES);\n    spaceshipRenderer.setupForDrawing();\n    scene.state.spaceships.forEach(spaceship => {\n      program.transform.set(projectionTransform.multiply(spaceship.transform));\n      spaceshipRenderer.draw();\n    });\n\n    if (ui.showColliders.checked) {\n      circleRenderer.setupForDrawing();\n      scene.state.spaceships.forEach(spaceship => {\n        const transform = projectionTransform.multiply(spaceship.getColliderTransform());\n        drawCollider(transform, program.transform, circleRenderer);\n      });\n    }\n\n    if (!ui.pause.checked) {\n      screenClick.check(coords => {\n        scene = scene.shootRay(new CameraRay({\n          program, cameraTransform, canvas, coords, perspective\n        }));\n      });\n\n      scene = scene.update();\n    }\n\n    window.requestAnimationFrame(render);\n  };\n\n  render();\n});\n","import { Matrix3D } from \"./matrix-3d\";\n\nfunction createShader(gl: WebGLRenderingContext, type: number, source: string): WebGLShader {\n  const shader = gl.createShader(type);\n  if (!shader) throw new Error(\"gl.createShader() failed!\");\n\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n  if (!success) {\n    const msg = \"Compiling shader failed: \" + gl.getShaderInfoLog(shader);\n    gl.deleteShader(shader);\n    throw new Error(msg);\n  }\n\n  return shader;\n}\n\nfunction createProgram(gl: WebGLRenderingContext, vertexShader: WebGLShader, fragmentShader: WebGLShader): WebGLProgram {\n  const program = gl.createProgram();\n  if (!program) throw new Error(\"gl.createProgram() failed!\");\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n\n  const success = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (!success) {\n    const msg = \"Linking program failed: \" + gl.getProgramInfoLog(program);\n    gl.deleteProgram(program);\n    throw new Error(msg);\n  }\n\n  return program;\n}\n\nfunction getUniformLocation(gl: WebGLRenderingContext, program: WebGLProgram, name: string): WebGLUniformLocation {\n  const loc = gl.getUniformLocation(program, name);\n\n  if (loc === null) {\n    throw new Error(`Unable to find uniform '${name}'!`);\n  }\n\n  return loc;\n}\n\nexport function getAttribLocation(gl: WebGLRenderingContext, program: WebGLProgram, name: string): number {\n  const loc = gl.getAttribLocation(program, name);\n\n  if (loc === -1) {\n    throw new Error(`Unable to find attribute '${name}'!`);\n  }\n\n  return loc;\n}\n\nexport class GlProgram {\n  readonly program: WebGLProgram;\n\n  constructor(readonly gl: WebGLRenderingContext, vertexShaderSrc: string, fragmentShaderSrc: string) {\n    const vertexShader = createShader(gl, WebGLRenderingContext.VERTEX_SHADER, vertexShaderSrc);\n    const fragmentShader = createShader(gl, WebGLRenderingContext.FRAGMENT_SHADER, fragmentShaderSrc);\n    this.program = createProgram(gl, vertexShader, fragmentShader);\n  }\n\n  activate() {\n    this.gl.useProgram(this.program);\n  }\n}\n\nclass GlUniformBase {\n  location: WebGLUniformLocation;\n\n  constructor(readonly program: GlProgram, name: string) {\n    this.location = getUniformLocation(program.gl, program.program, name);\n  }\n}\n\nexport class GlUniformVector extends GlUniformBase {\n  set(value: Float32List) {\n    this.program.gl.uniform4fv(this.location, value);\n  }\n}\n\nexport class GlUniformFloat extends GlUniformBase {\n  set(value: number) {\n    this.program.gl.uniform1f(this.location, value);\n  }\n}\n\nexport class GlUniformMatrix3D extends GlUniformBase {\n  set(value: Matrix3D) {\n    this.program.gl.uniformMatrix4fv(this.location, false, value.toFloat32Array());\n  }\n}\n","import { GlProgram } from \"./webgl\";\nimport { Points3D } from \"./points-3d\";\n\nexport interface Points3DRendererProgram extends GlProgram {\n  positionAttributeLocation: number;\n}\n\nexport class Points3DRenderer {\n  buffer: WebGLBuffer;\n\n  constructor(readonly program: Points3DRendererProgram, readonly points: Points3D) {\n    const { gl } = program;\n    const buffer = gl.createBuffer();\n\n    if (buffer === null) {\n      throw new Error(\"gl.createBuffer() failed!\");\n    }\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, points.toFloat32Array(), gl.STATIC_DRAW);\n\n    this.buffer = buffer;\n  }\n\n  setupForDrawing() {\n    const { gl, positionAttributeLocation } = this.program;\n\n    gl.enableVertexAttribArray(positionAttributeLocation);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n\n    const vertexSize = 3;\n    const type = gl.FLOAT;\n    const normalize = false;\n    const stride = 0;\n    const offset = 0;\n    gl.vertexAttribPointer(positionAttributeLocation, vertexSize, type, normalize, stride, offset);\n  }\n\n  draw(primitiveType: number = WebGLRenderingContext.TRIANGLES) {\n    const { gl } = this.program;\n    const drawOffset = 0;\n    const count = this.points.length;\n    gl.drawArrays(primitiveType, drawOffset, count);  \n  }\n}\n","import { Matrix3D } from \"./matrix-3d\";\nimport { Vector3D } from \"./vector-3d\";\n\ntype InvertOp = (m: Matrix3D) => Matrix3D;\n\n/**\n * A class that keeps track of simple 3D transformations made to it, so\n * its inverse can be easily computed.\n * \n * I originally thought this idea was too silly to use in practice, but\n * it's actually documented in Real-Time Rendering, 4th edition,\n * section 4.1.8 (page 69) as a perfectly valid way to invert many\n * kinds of matrices we're interested in.\n */\nexport class InvertibleTransforms3D {\n  constructor(readonly matrix: Matrix3D = new Matrix3D(), private ops: InvertOp[] = []) {\n  }\n\n  private addOp(matrix: Matrix3D, op: InvertOp): InvertibleTransforms3D {\n    return new InvertibleTransforms3D(matrix, [op, ...this.ops]);\n  }\n\n  translate(v: Vector3D): InvertibleTransforms3D;\n  translate(x: number, y: number, z: number): InvertibleTransforms3D;\n\n  translate(x: Vector3D|number, y?: number, z?: number): InvertibleTransforms3D {\n    const vector = Vector3D.fromVectorOrCoords(x, y, z);\n\n    return this.addOp(\n      this.matrix.translate(vector),\n      m => m.translate(vector.times(-1))\n    );\n  }\n\n  /** Rotate counter-clockwise around the X axis. */\n  rotateX(radians: number) {\n    return this.addOp(\n      this.matrix.rotateX(radians),\n      m => m.rotateX(-radians)\n    );\n  }\n\n  /** Rotate counter-clockwise around the Y axis. */\n  rotateY(radians: number) {\n    return this.addOp(\n      this.matrix.rotateY(radians),\n      m => m.rotateY(-radians)\n    );\n  }\n\n  /** Rotate counter-clockwise around the Z axis. */\n  rotateZ(radians: number) {\n    return this.addOp(\n      this.matrix.rotateZ(radians),\n      m => m.rotateZ(-radians)\n    );\n  }\n\n  /** Return the inverse of the matrix. */\n  inverse(): Matrix3D {\n    let matrix = new Matrix3D();\n\n    for (let inverseOp of this.ops) {\n      matrix = inverseOp(matrix);\n    }\n\n    return matrix;\n  }\n}\n","import { Points3D } from \"./points-3d\";\nimport { Vector3D } from \"./vector-3d\";\nimport { Ray3D } from \"./ray-3d\";\nimport { Matrix3D } from \"./matrix-3d\";\n\nexport function makeSpaceship(): Points3D {\n  const translate = new Matrix3D().translate(0, -0.25, 0);\n  const mirror = new Matrix3D().scale(-1, 1, 1);\n  const leftHalf = translate.transformPoints(Points3D.fromArray([\n    -0.5, 0, 0,\n    0, 0.75, 0,\n    0, 0.15, 0\n  ]));\n\n  return leftHalf.concat(mirror.transformPoints(leftHalf));\n}\n\nexport function makeGround(y = -1, xzStart = -1, size = 2, pointsPerAxis = 20): Points3D {\n  const points: number[] = [];\n  let xPart = xzStart;\n  let zPart = xzStart;\n  let partInc = 1 / pointsPerAxis;\n\n  for (let i = 0; i <= pointsPerAxis; i++) {\n    points.push(xPart, y, zPart);\n    points.push(xPart, y, zPart + size);\n    xPart += size * partInc;\n  }\n\n  xPart = xzStart;\n  for (let i = 0; i <= pointsPerAxis; i++) {\n    points.push(xPart, y, zPart);\n    points.push(xPart + size, y, zPart);\n    zPart += size * partInc;\n  }\n\n  return Points3D.fromArray(points);\n}\n\nexport function makeRayPoints(ray: Ray3D, segments = 1, length = 5): Points3D {\n  let point = ray.origin;\n  const increment = ray.direction.times(length / segments);\n  const points: number[] = [];\n\n  for (let i = 0; i < segments; i++) {\n    points.push(point.x, point.y, point.z);\n    point = point.plus(increment);\n    points.push(point.x, point.y, point.z);\n  }\n\n  return Points3D.fromArray(points);\n}\n\nexport function makeCircle(segments = 20): Points3D {\n  const points: number[] = [];\n  const start = new Vector3D(1, 0, 0);\n\n  for (let i = 0; i < segments; i++) {\n    const rotation = new Matrix3D().rotateZ(2 * Math.PI * (i / segments));\n    const p = rotation.transformVector(start);\n    points.push(p.x, p.y, p.z);\n  }\n\n  return Points3D.fromArray(points);\n}\n","import { Vector3D } from \"./vector-3d\";\n\nexport class Points3D {\n  constructor(private readonly array: Vector3D[]) {\n  }\n\n  toFloat32Array(): Float32Array {\n    const { array } = this;\n    const result = new Float32Array(array.length * 3);\n    let arrIndex = 0;\n\n    for (let i = 0; i < result.length; i += 3) {\n      result[i] = array[arrIndex].x;\n      result[i + 1] = array[arrIndex].y;\n      result[i + 2] = array[arrIndex].z;\n      arrIndex += 1;\n    }\n\n    return result;\n  }\n\n  concat(points: Points3D): Points3D {\n    const combined = this.array.concat(points.array);\n    return new Points3D(combined);\n  }\n\n  map(fn: (v: Vector3D) => Vector3D) {\n    return new Points3D(this.array.map(fn));\n  }\n\n  get length(): number {\n    return this.array.length;\n  }\n\n  static fromArray(array: number[]|Float32Array) {\n    const numPoints = array.length / 3;\n    const pointArray = new Array<Vector3D>(numPoints);\n    let arrIndex = 0;\n    for (let i = 0; i < numPoints; i++) {\n      const x = array[arrIndex];\n      const y = array[arrIndex + 1];\n      const z = array[arrIndex + 2];\n      pointArray[i] = new Vector3D(x, y, z);\n      arrIndex += 3;\n    }\n    return new Points3D(pointArray);\n  }\n}\n","import { PerspectiveOptions, Matrix3D } from \"./matrix-3d\";\nimport { Vector3D } from \"./vector-3d\";\n\nexport type Point2D = {\n  x: number,\n  y: number\n};\n\nexport type Dimensions2D = {\n  width: number,\n  height: number\n};\n\n/**\n * Convert the given screen coordinates, in pixels, to\n * eye coordinates (from the perspective of the camera).\n */\nfunction screenCoordsToEye(canvas: Dimensions2D, point: Point2D, perspective: PerspectiveOptions): Vector3D {\n  const width = perspective.right - perspective.left;\n  const height = perspective.top - perspective.bottom;\n  const xPct = (point.x / canvas.width);\n  // Note that we need to flip the y-axis.\n  const yPct = ((canvas.height - point.y) / canvas.height);\n\n  const x = perspective.left + xPct * width;\n  const y = perspective.bottom + yPct * height;\n\n  // We need to flip the near value because it's specified in\n  // clip coordinates.\n  const z = -perspective.near;\n\n  return new Vector3D(x, y, z);\n}\n\n/**\n * Convert the given pixel coordinates on the given canvas to\n * points in the world.\n */\nexport function screenCoordsToWorld(\n  canvas: Dimensions2D,\n  point: Point2D,\n  perspective: PerspectiveOptions,\n  cameraTransform: Matrix3D\n): Vector3D {\n  const pointRelativeToCamera = screenCoordsToEye(canvas, point, perspective);\n  return cameraTransform.transformVector(pointRelativeToCamera);\n}\n","/**\n * Convenience class to store a value and detect\n * whether it has changed since the last time\n * we checked.\n */\nexport class CheckableValue<T> {\n  private lastCheckedValue: T|null = null;\n  private value: T|null = null;\n\n  /** Set the value. */\n  set(value: T) {\n    this.value = value;\n  }\n\n  /**\n   * If the value has changed since the last\n   * time we checked, pass it to the given callback\n   * function. Otherwise, do nothing.\n   */\n  check(cb: (value: T) => void) {\n    if (this.value === this.lastCheckedValue) {\n      return;\n    }\n    this.lastCheckedValue = this.value;\n    if (this.value) {\n      cb(this.value);\n    }\n  }\n}\n","import { Vector3D } from \"./vector-3d\";\n\n/**\n * An abstraction for a normalized ray that emanates\n * from an origin in a direction.\n */\nexport class Ray3D {\n  readonly direction: Vector3D;\n\n  constructor(readonly origin: Vector3D, direction: Vector3D) {\n    this.direction = direction.normalize();\n  }\n\n  pointAlong(t: number): Vector3D {\n    return this.origin.plus(this.direction.times(t));\n  }\n\n  static fromTo(from: Vector3D, to: Vector3D): Ray3D {\n    const direction = to.minus(from);\n    return new Ray3D(from, direction);\n  }\n}\n","import { Vector3D } from \"./vector-3d\";\nimport { Ray3D } from \"./ray-3d\";\n\n/**\n * Tests for ray/sphere intersection, returning null if the\n * ray never intersects with the sphere, or the vector\n * representing the closest point of intersection.\n * \n * Derivation for this can be found in Real-Time Rendering,\n * 4th edition, 22.6.1 (page 956).\n */\nexport function getRaySphereIntersection(ray: Ray3D, center: Vector3D, radius: number): null | Vector3D {\n  const originMinusCenter = ray.origin.minus(center);\n  const b = ray.direction.dot(originMinusCenter);\n  const c = originMinusCenter.dot(originMinusCenter) - radius * radius;\n  const bSquaredMinusC = b * b - c;\n\n  if (bSquaredMinusC < 0) {\n    return null;\n  }\n\n  const sqrt = Math.sqrt(bSquaredMinusC);\n  const t = [-b + sqrt, -b - sqrt].filter(value => value >= 0);\n  if (t.length === 0) {\n    return null;\n  }\n\n  const closestT = t.sort((a, b) => a - b)[0];\n  return ray.pointAlong(closestT);\n}\n","/**\n * Find an element.\n * \n * @param tagName The name of the element's HTML tag.\n * @param selector The selector for the element, not including its HTML tag.\n * @param parent The parent node to search within.\n */\nexport function getElement<K extends keyof HTMLElementTagNameMap>(\n  tagName: K,\n  selector: string,\n  parent: ParentNode = document\n): HTMLElementTagNameMap[K] {\n  const finalSelector = `${tagName}${selector}`;\n  const node = parent.querySelector(finalSelector);\n  if (!node) {\n    throw new Error(`Couldn't find any elements matching \"${finalSelector}\"`);\n  }\n  return node as HTMLElementTagNameMap[K];\n}\n","type KeyboardMapHandler = () => void;\n\nexport class KeyboardMap {\n  mapping: Map<string, KeyboardMapHandler> = new Map();\n\n  constructor() {\n    document.body.addEventListener('keypress', e => this.handleEvent(e));\n  }\n\n  private addKbdElement(key: string, el: Node) {\n    const kbd = document.createElement('kbd');\n    kbd.textContent = key;\n    el.appendChild(document.createTextNode(' '));\n    el.appendChild(kbd);\n  }\n\n  private handleEvent(e: KeyboardEvent) {\n    const handler = this.mapping.get(e.key.toLowerCase());\n    if (handler) {\n      handler();\n    }\n  }\n\n  set(key: string, handler: KeyboardMapHandler, labelNode?: Node|null) {\n    this.mapping.set(key, handler);\n    if (labelNode) {\n      this.addKbdElement(key, labelNode);\n    }\n  }\n\n  setCheckboxToggler(key: string, el: HTMLInputElement) {\n    this.set(key, checkboxToggler(el), el.parentNode);\n  }\n}\n\nfunction checkboxToggler(el: HTMLInputElement): KeyboardMapHandler {\n  return () => el.checked = !el.checked;\n}\n","module.exports = \"attribute vec4 a_position;\\n\\nuniform mat4 u_transform;\\n\\nvoid main() {\\n  gl_Position = u_transform * a_position;\\n}\\n\";","module.exports = \"precision mediump float;\\n\\nvoid main() {\\n  // This essentially visualizes the z-buffer. Taken from:\\n  //\\n  //   https://learnopengl.com/Advanced-OpenGL/Depth-testing\\n  gl_FragColor = vec4(vec3(gl_FragCoord.z), 1.0);\\n}\\n\";"],"sourceRoot":""}