{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/vector-3d.ts","webpack:///./src/matrix-3d.ts","webpack:///./src/app.ts","webpack:///./src/webgl.ts","webpack:///./src/points-3d-renderer.ts","webpack:///./src/invertible-transforms-3d.ts","webpack:///./src/shapes.ts","webpack:///./src/points-3d.ts","webpack:///./src/screen-space.ts","webpack:///./src/checkable-value.ts","webpack:///./src/ray-3d.ts","webpack:///./src/intersections.ts","webpack:///./src/get-element.ts","webpack:///./src/simple-vertex-shader.glsl","webpack:///./src/z-buffer-fragment-shader.glsl"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Vector3D","[object Object]","x","y","z","w","this","v","len","Math","sqrt","vector_3d_1","IDENTITY","Matrix3D","values","valueAt","Float32Array","row","column","fromVectorOrCoords","multiply","radians","cos","sin","m2","col1","transformVector","col2","col3","col4","f","map","options","near","far","left","right","top","bottom","width","height","depth","doubleNear","col","webgl_1","points_3d_renderer_1","matrix_3d_1","invertible_transforms_3d_1","shapes_1","screen_space_1","checkable_value_1","ray_3d_1","intersections_1","get_element_1","simpleVertexShaderSrc","zBufferFragmentShaderSrc","Spaceship","orbitTheta","random","orbitThetaVelocity","distanceFromCenter","scale","shipTheta","shipThetaVelocity","intersectionRadiusScale","transform","recomputeTransform","rotateZ","translate","rotateY","intersectionRadius","ray","getRaySphereIntersection","center","window","addEventListener","canvas","document","createElement","body","appendChild","style","border","gl","getContext","Error","showCollidersCheckbox","getElement","program","GlProgram","super","GlUniformMatrix3D","positionAttributeLocation","getAttribLocation","spaceshipRenderer","Points3DRenderer","makeSpaceship","groundRenderer","makeGround","circleRenderer","makeCircle","rayRenderer","perspective","baseProjectionTransform","perspectiveProjection","spaceships","screenClick","CheckableValue","push","onclick","e","set","offsetX","offsetY","console","log","cameraRotation","render","cameraTransform","InvertibleTransforms3D","viewTransform","inverse","projectionTransform","check","coords","cameraPosition","matrix","getCameraPosition","screenPointInWorld","screenCoordsToWorld","Ray3D","fromTo","filter","doesRayIntersect","makeRayPoints","viewport","enable","DEPTH_TEST","clearColor","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","activate","setupForDrawing","draw","LINES","forEach","spaceship","update","checked","getIntersectionSphereTransform","LINE_LOOP","rotateX","PI","requestAnimationFrame","createShader","type","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","msg","getShaderInfoLog","deleteShader","loc","vertexShaderSrc","fragmentShaderSrc","vertexShader","WebGLRenderingContext","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","useProgram","GlUniformBase","location","getUniformLocation","GlUniformVector","uniform4fv","GlUniformFloat","uniform1f","uniformMatrix4fv","toFloat32Array","points","buffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","enableVertexAttribArray","FLOAT","vertexAttribPointer","primitiveType","TRIANGLES","count","length","drawArrays","ops","op","vector","addOp","times","inverseOp","points_3d_1","leftHalf","Points3D","fromArray","concat","mirrorHorizontally","xzStart","size","pointsPerAxis","xPart","zPart","partInc","segments","point","origin","increment","direction","plus","start","array","result","arrIndex","combined","numPoints","pointArray","Array","pointRelativeToCamera","xPct","yPct","screenCoordsToEye","lastCheckedValue","cb","normalize","from","to","minus","radius","originMinusCenter","b","dot","bSquaredMinusC","closestT","sort","a","pointAlong","tagName","selector","parent","finalSelector","node","querySelector"],"mappings":"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","file":"app.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","/**\n * A three-dimensional vector. Note that it actually has\n * four elements because we use a homogeneous coordinate\n * system.\n */\nexport class Vector3D {\n  constructor(readonly x: number, readonly y: number, readonly z: number, readonly w: number = 1.0) {\n  }\n\n  perspectiveDivide(): Vector3D {\n    const { x, y, z, w } = this;\n    return new Vector3D(x / w, y / w, z / w);\n  }\n\n  minus(v: Vector3D): Vector3D {\n    const { x, y, z, w } = this;\n    return new Vector3D(x - v.x, y - v.y, z - v.z, w);\n  }\n\n  plus(v: Vector3D): Vector3D {\n    const { x, y, z, w } = this;\n    return new Vector3D(x + v.x, y + v.y, z + v.z, w);\n  }\n\n  times(n: number): Vector3D {\n    const { x, y, z, w } = this;\n    return new Vector3D(x * n, y * n, z * n, w);\n  }\n\n  dot(v: Vector3D): number {\n    const { x, y, z, w } = this;\n\n    return x * v.x + y * v.y + z * v.z;\n  }\n\n  normalize(): Vector3D {\n    const { x, y, z, w } = this;\n    const len = Math.sqrt(x * x + y * y + z * z);\n    return new Vector3D(x / len, y / len, z / len, w);\n  }\n\n  /**\n   * A helper to convert either a vector or a sequence of coordinates\n   * into a vector.\n   */\n  static fromVectorOrCoords(x: Vector3D | number, y?: number, z?: number): Vector3D {\n    z = x instanceof Vector3D ? x.z : z || 0;\n    y = x instanceof Vector3D ? x.y : y || 0;\n    x = x instanceof Vector3D ? x.x : x;\n    return new Vector3D(x, y, z);\n  }\n}","import { Vector3D } from \"./vector-3d\";\n\ntype Column = 1|2|3|4;\ntype Row = 1|2|3|4;\n\n/**\n * A 4x4 matrix represented as\n * a two-dimensional array in\n * row-major order.\n */\ntype Matrix3DTuple = [\n  [number, number, number, number],\n  [number, number, number, number],\n  [number, number, number, number],\n  [number, number, number, number]\n];\n\nexport type PerspectiveOptions = {\n  left: number;\n  right: number;\n  top: number;\n  bottom: number;\n  near: number;\n  far: number;\n};\n\nconst IDENTITY: Matrix3DTuple = [\n  [1, 0, 0, 0],\n  [0, 1, 0, 0],\n  [0, 0, 1, 0],\n  [0, 0, 0, 1]\n];\n\n/**\n * A three-dimensional matrix. Note that it ultimately represents a 4x4\n * matrix because we use homogeneous coordinates.\n */\nexport class Matrix3D {\n  constructor(readonly values: Matrix3DTuple = IDENTITY) {\n    this.valueAt = this.valueAt.bind(this);\n  }\n\n  /**\n   * Convert the matrix into a Float32Array in column-major order\n   * (the layout that GLSL expects).\n   */\n  toFloat32Array(): Float32Array {\n    const m = this.valueAt;\n    return new Float32Array([\n      m(1, 1), m(2, 1), m(3, 1), m(4, 1),\n      m(1, 2), m(2, 2), m(3, 2), m(4, 2),\n      m(1, 3), m(2, 3), m(3, 3), m(4, 3),\n      m(1, 4), m(2, 4), m(3, 4), m(4, 4),\n    ]);\n  }\n\n  valueAt(row: Row, column: Column): number {\n    return this.values[row - 1][column - 1];\n  }\n\n  translate(v: Vector3D): Matrix3D;\n  translate(x: number, y: number, z: number): Matrix3D;\n\n  translate(x: Vector3D|number, y?: number, z?: number): Matrix3D {\n    const v = Vector3D.fromVectorOrCoords(x, y, z);\n\n    return this.multiply(new Matrix3D([\n      [1, 0, 0, v.x],\n      [0, 1, 0, v.y],\n      [0, 0, 1, v.z],\n      [0, 0, 0,   1]\n    ]));\n  }\n\n  scale(v: number) {\n    return this.multiply(new Matrix3D([\n      [v, 0, 0, 0],\n      [0, v, 0, 0],\n      [0, 0, v, 0],\n      [0, 0, 0, 1]\n    ]));\n  }\n\n  /** Rotate counter-clockwise around the X axis. */\n  rotateX(radians: number) {\n    // Deriving this requires the trigonometric identities for angle sums:\n    //\n    //   https://en.wikipedia.org/wiki/List_of_trigonometric_identities\n    //\n    // That said, I think an alternative approach is to think of rotation\n    // as transformation of basis vectors via matrix multiplication,\n    // which simplifies things conceptually.\n    const c = Math.cos(radians);\n    const s = Math.sin(radians);\n    return this.multiply(new Matrix3D([\n      [1,  0, 0, 0],\n      [0,  c, s, 0],\n      [0, -s, c, 0],\n      [0,  0, 0, 1]\n    ]));\n  }\n\n  /** Rotate counter-clockwise around the Y axis. */\n  rotateY(radians: number) {\n    const c = Math.cos(radians);\n    const s = Math.sin(radians);\n    return this.multiply(new Matrix3D([\n      [c, 0, -s, 0],\n      [0, 1,  0, 0],\n      [s, 0,  c, 0],\n      [0, 0,  0, 1]\n    ]));\n  }\n\n  /** Rotate counter-clockwise around the Z axis. */\n  rotateZ(radians: number) {\n    const c = Math.cos(radians);\n    const s = Math.sin(radians);\n    return this.multiply(new Matrix3D([\n      [c, -s, 0, 0],\n      [s,  c, 0, 0],\n      [0,  0, 1, 0],\n      [0,  0, 0, 1]\n    ]));\n  }\n\n  multiply(m2: Matrix3D): Matrix3D {\n    // Conceptualy, it's easiest to think of matrix multiplication\n    // as a transformation of a coordinate system's basis\n    // vectors:\n    //\n    //   http://www.3blue1brown.com/essence-of-linear-algebra-page/\n    //\n    // This isn't particularly efficient code, but hopefully\n    // it is readable.\n    const col1 = this.transformVector(m2.column(1));\n    const col2 = this.transformVector(m2.column(2));\n    const col3 = this.transformVector(m2.column(3));\n    const col4 = this.transformVector(m2.column(4));\n    return new Matrix3D([\n      [col1.x, col2.x, col3.x, col4.x],\n      [col1.y, col2.y, col3.y, col4.y],\n      [col1.z, col2.z, col3.z, col4.z],\n      [col1.w, col2.w, col3.w, col4.w],\n    ]);\n  }\n\n  /**\n   * Apply the given function to every element of the matrix, returning\n   * a new one.\n   */\n  map(f: (value: number) => number): Matrix3D {\n    return new Matrix3D(this.values.map(row => row.map(f)) as Matrix3DTuple);\n  }\n\n  /**\n   * Multiply all elements of the matrix by the given constant,\n   * returning a new matrix.\n   */\n  multiplyByConstant(n: number): Matrix3D {\n    return this.map(value => value * n);\n  }\n\n  /**\n   * Create a matrix that transforms eye coordinates into clip\n   * coordinates.\n   * \n   * Note that clip coordinates will likely have a w-component\n   * that is not 1; the GPU will perform a perspective divide\n   * after the vertex shader to convert the clip coordinates\n   * into normalized device coordinates (NDC).\n   * \n   * Note also that the near and far parameters must be\n   * specified as positive numbers, as the clip coordinates\n   * use a left-handed coordinate system, while the\n   * eye coordinates use a right-handed coordinate system,\n   * and the projection matrix will convert between the\n   * two.\n   * \n   * For more details, as well as an excellent derivation\n   * of all the math behind all this, see:\n   * \n   *   http://www.songho.ca/opengl/gl_projectionmatrix.html#perspective\n   */\n  static perspectiveProjection(options: PerspectiveOptions): Matrix3D {\n    const { near, far, left, right, top, bottom } = options;\n    const width = right - left;\n    const height = top - bottom;\n    const depth = far - near;\n    const doubleNear = 2 * near;\n    return new Matrix3D([\n      [doubleNear / width, 0, (right + left) / width, 0],\n      [0, doubleNear / height, (top + bottom) / height, 0],\n      [0, 0, -(far + near) / depth, -2 * far * near / depth],\n      [0, 0, -1, 0]\n    ]);\n  }\n\n  transformVector(v: Vector3D): Vector3D {\n    const m = this.valueAt;\n    return new Vector3D(\n      m(1, 1) * v.x + m(1, 2) * v.y + m(1, 3) * v.z + m(1, 4) * v.w,\n      m(2, 1) * v.x + m(2, 2) * v.y + m(2, 3) * v.z + m(2, 4) * v.w,\n      m(3, 1) * v.x + m(3, 2) * v.y + m(3, 3) * v.z + m(3, 4) * v.w,\n      m(4, 1) * v.x + m(4, 2) * v.y + m(4, 3) * v.z + m(4, 4) * v.w,\n    );\n  }\n\n  column(col: Column): Vector3D {\n    const m = this.valueAt;\n    return new Vector3D(\n      m(1, col),\n      m(2, col),\n      m(3, col),\n      m(4, col)\n    );\n  }\n}\n","import { GlProgram, getAttribLocation, GlUniformMatrix3D } from \"./webgl\";\nimport { Points3DRenderer } from \"./points-3d-renderer\";\nimport { Matrix3D, PerspectiveOptions } from \"./matrix-3d\";\nimport { Vector3D } from \"./vector-3d\";\nimport { InvertibleTransforms3D } from \"./invertible-transforms-3d\";\nimport { makeSpaceship, makeGround, makeRayPoints, makeCircle } from \"./shapes\";\nimport { Point2D, screenCoordsToWorld } from \"./screen-space\";\nimport { CheckableValue } from \"./checkable-value\";\nimport { Ray3D } from \"./ray-3d\";\nimport { getRaySphereIntersection } from \"./intersections\";\nimport { getElement } from \"./get-element\";\n\nconst simpleVertexShaderSrc = require(\"./simple-vertex-shader.glsl\") as string;\nconst zBufferFragmentShaderSrc = require(\"./z-buffer-fragment-shader.glsl\") as string;\n\nclass SimpleGlProgram extends GlProgram {\n  readonly transform: GlUniformMatrix3D;\n  readonly positionAttributeLocation: number;\n\n  constructor(gl: WebGLRenderingContext) {\n    super(gl, simpleVertexShaderSrc, zBufferFragmentShaderSrc);\n    this.transform = new GlUniformMatrix3D(this, 'u_transform');\n    this.positionAttributeLocation = getAttribLocation(gl, this.program, 'a_position');\n  }\n}\n\nclass Spaceship {\n  orbitTheta = Math.random();\n  orbitThetaVelocity = Math.random() * 0.01;\n  distanceFromCenter = Math.random();\n  scale = 0.5;\n  shipTheta = Math.random();\n  shipThetaVelocity = Math.random() * 0.05;\n  transform: Matrix3D;\n  readonly intersectionRadiusScale = 0.5;\n\n  constructor(readonly z: number) {\n    this.transform = this.recomputeTransform();\n  }\n\n  recomputeTransform(): Matrix3D {\n    const transform = new Matrix3D()\n      .rotateZ(this.orbitTheta)\n      .translate(this.distanceFromCenter, 0, this.z)\n      .scale(this.scale)\n      .rotateY(this.shipTheta);\n\n    return this.transform = transform;\n  }\n\n  get intersectionRadius(): number {\n    return this.scale * this.intersectionRadiusScale;\n  }\n\n  getIntersectionSphereTransform(): Matrix3D {\n    return this.transform.scale(this.intersectionRadiusScale);\n  }\n\n  center(): Vector3D {\n    return this.transform.transformVector(new Vector3D(0, 0, 0));\n  }\n\n  doesRayIntersect(ray: Ray3D): boolean {\n    return getRaySphereIntersection(ray, this.center(), this.intersectionRadius) !== null;\n  }\n\n  update() {\n    this.orbitTheta += this.orbitThetaVelocity;\n    this.shipTheta += this.shipThetaVelocity;\n    this.recomputeTransform();\n  }\n};\n\nfunction getCameraPosition(cameraTransform: InvertibleTransforms3D): Vector3D {\n  return cameraTransform.matrix.transformVector(new Vector3D(0, 0, 0));\n}\n\nwindow.addEventListener('DOMContentLoaded', () => {\n  const canvas = document.createElement('canvas');\n\n  document.body.appendChild(canvas);\n  canvas.width = 800;\n  canvas.height = 800;\n  canvas.style.border = '1px solid black';\n\n  const gl = canvas.getContext('webgl');\n  if (!gl) throw new Error(\"webgl is not supported on this browser!\");\n\n  const showCollidersCheckbox = getElement('input', '#show-colliders');\n  const program = new SimpleGlProgram(gl);\n  const spaceshipRenderer = new Points3DRenderer(program, makeSpaceship());\n  const groundRenderer = new Points3DRenderer(program, makeGround());\n  const circleRenderer = new Points3DRenderer(program, makeCircle());\n  let rayRenderer: Points3DRenderer|null = null;\n  const perspective: PerspectiveOptions = {\n    top: 1,\n    bottom: -1,\n    right: 1,\n    left: -1,\n    near: 1,\n    far: 3\n  };\n  const baseProjectionTransform = Matrix3D.perspectiveProjection(perspective);\n  let spaceships: Spaceship[] = [];\n  const NUM_SPACESHIPS = 30;\n  let screenClick = new CheckableValue<Point2D>();\n\n  for (let i = 0; i < NUM_SPACESHIPS; i++) {\n    spaceships.push(new Spaceship(-1 + ((i / NUM_SPACESHIPS) * 2)));\n  }\n\n  canvas.onclick = (e) => { screenClick.set({x: e.offsetX, y: e.offsetY}); };\n\n  console.log(\"Initialization successful!\");\n\n  let cameraRotation = 0;\n\n  const render = () => {\n    const cameraTransform = new InvertibleTransforms3D()\n      .rotateY(cameraRotation)\n      .translate(0, 0, 2.25);\n    const viewTransform = cameraTransform.inverse();\n    const projectionTransform = baseProjectionTransform.multiply(viewTransform);\n\n    screenClick.check(coords => {\n      const cameraPosition = getCameraPosition(cameraTransform);\n      const screenPointInWorld = screenCoordsToWorld(\n        canvas,\n        coords,\n        perspective,\n        cameraTransform.matrix\n      );\n      const ray = Ray3D.fromTo(cameraPosition, screenPointInWorld);\n      spaceships = spaceships.filter(s => !s.doesRayIntersect(ray));\n      rayRenderer = new Points3DRenderer(program, makeRayPoints(ray));\n    });\n\n    cameraRotation += 0.001;\n\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n    gl.enable(gl.DEPTH_TEST);\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    program.activate();\n    if (rayRenderer) {\n      rayRenderer.setupForDrawing();\n      program.transform.set(projectionTransform);\n      rayRenderer.draw(gl.LINES);\n    }\n    groundRenderer.setupForDrawing();\n    program.transform.set(projectionTransform);\n    groundRenderer.draw(gl.LINES);\n    spaceshipRenderer.setupForDrawing();\n    spaceships.forEach(spaceship => {\n      program.transform.set(projectionTransform.multiply(spaceship.transform));\n      spaceshipRenderer.draw();\n      spaceship.update();\n    });\n\n    if (showCollidersCheckbox.checked) {\n      circleRenderer.setupForDrawing();\n      spaceships.forEach(spaceship => {\n        const transform = projectionTransform.multiply(\n          spaceship.getIntersectionSphereTransform()\n        );\n        program.transform.set(transform);\n        circleRenderer.draw(gl.LINE_LOOP);\n        program.transform.set(transform.rotateX(Math.PI / 2));\n        circleRenderer.draw(gl.LINE_LOOP);\n        program.transform.set(transform.rotateY(Math.PI / 2));\n        circleRenderer.draw(gl.LINE_LOOP);\n      });\n    }\n\n    window.requestAnimationFrame(render);\n  };\n\n  render();\n});\n","import { Matrix3D } from \"./matrix-3d\";\n\nfunction createShader(gl: WebGLRenderingContext, type: number, source: string): WebGLShader {\n  const shader = gl.createShader(type);\n  if (!shader) throw new Error(\"gl.createShader() failed!\");\n\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n  if (!success) {\n    const msg = \"Compiling shader failed: \" + gl.getShaderInfoLog(shader);\n    gl.deleteShader(shader);\n    throw new Error(msg);\n  }\n\n  return shader;\n}\n\nfunction createProgram(gl: WebGLRenderingContext, vertexShader: WebGLShader, fragmentShader: WebGLShader): WebGLProgram {\n  const program = gl.createProgram();\n  if (!program) throw new Error(\"gl.createProgram() failed!\");\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n\n  const success = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (!success) {\n    const msg = \"Linking program failed: \" + gl.getProgramInfoLog(program);\n    gl.deleteProgram(program);\n    throw new Error(msg);\n  }\n\n  return program;\n}\n\nfunction getUniformLocation(gl: WebGLRenderingContext, program: WebGLProgram, name: string): WebGLUniformLocation {\n  const loc = gl.getUniformLocation(program, name);\n\n  if (loc === null) {\n    throw new Error(`Unable to find uniform '${name}'!`);\n  }\n\n  return loc;\n}\n\nexport function getAttribLocation(gl: WebGLRenderingContext, program: WebGLProgram, name: string): number {\n  const loc = gl.getAttribLocation(program, name);\n\n  if (loc === -1) {\n    throw new Error(`Unable to find attribute '${name}'!`);\n  }\n\n  return loc;\n}\n\nexport class GlProgram {\n  readonly program: WebGLProgram;\n\n  constructor(readonly gl: WebGLRenderingContext, vertexShaderSrc: string, fragmentShaderSrc: string) {\n    const vertexShader = createShader(gl, WebGLRenderingContext.VERTEX_SHADER, vertexShaderSrc);\n    const fragmentShader = createShader(gl, WebGLRenderingContext.FRAGMENT_SHADER, fragmentShaderSrc);\n    this.program = createProgram(gl, vertexShader, fragmentShader);\n  }\n\n  activate() {\n    this.gl.useProgram(this.program);\n  }\n}\n\nclass GlUniformBase {\n  location: WebGLUniformLocation;\n\n  constructor(readonly program: GlProgram, name: string) {\n    this.location = getUniformLocation(program.gl, program.program, name);\n  }\n}\n\nexport class GlUniformVector extends GlUniformBase {\n  set(value: Float32List) {\n    this.program.gl.uniform4fv(this.location, value);\n  }\n}\n\nexport class GlUniformFloat extends GlUniformBase {\n  set(value: number) {\n    this.program.gl.uniform1f(this.location, value);\n  }\n}\n\nexport class GlUniformMatrix3D extends GlUniformBase {\n  set(value: Matrix3D) {\n    this.program.gl.uniformMatrix4fv(this.location, false, value.toFloat32Array());\n  }\n}\n","import { GlProgram } from \"./webgl\";\nimport { Points3D } from \"./points-3d\";\n\nexport interface Points3DRendererProgram extends GlProgram {\n  positionAttributeLocation: number;\n}\n\nexport class Points3DRenderer {\n  buffer: WebGLBuffer;\n\n  constructor(readonly program: Points3DRendererProgram, readonly points: Points3D) {\n    const { gl } = program;\n    const buffer = gl.createBuffer();\n\n    if (buffer === null) {\n      throw new Error(\"gl.createBuffer() failed!\");\n    }\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, points.toFloat32Array(), gl.STATIC_DRAW);\n\n    this.buffer = buffer;\n  }\n\n  setupForDrawing() {\n    const { gl, positionAttributeLocation } = this.program;\n\n    gl.enableVertexAttribArray(positionAttributeLocation);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n\n    const vertexSize = 3;\n    const type = gl.FLOAT;\n    const normalize = false;\n    const stride = 0;\n    const offset = 0;\n    gl.vertexAttribPointer(positionAttributeLocation, vertexSize, type, normalize, stride, offset);\n  }\n\n  draw(primitiveType: number = WebGLRenderingContext.TRIANGLES) {\n    const { gl } = this.program;\n    const drawOffset = 0;\n    const count = this.points.length;\n    gl.drawArrays(primitiveType, drawOffset, count);  \n  }\n}\n","import { Matrix3D } from \"./matrix-3d\";\nimport { Vector3D } from \"./vector-3d\";\n\ntype InvertOp = (m: Matrix3D) => Matrix3D;\n\n/**\n * A class that keeps track of simple 3D transformations made to it, so\n * its inverse can be easily computed.\n * \n * I originally thought this idea was too silly to use in practice, but\n * it's actually documented in Real-Time Rendering, 4th edition,\n * section 4.1.8 (page 69) as a perfectly valid way to invert many\n * kinds of matrices we're interested in.\n */\nexport class InvertibleTransforms3D {\n  constructor(readonly matrix: Matrix3D = new Matrix3D(), private ops: InvertOp[] = []) {\n  }\n\n  private addOp(matrix: Matrix3D, op: InvertOp): InvertibleTransforms3D {\n    return new InvertibleTransforms3D(matrix, [op, ...this.ops]);\n  }\n\n  translate(v: Vector3D): InvertibleTransforms3D;\n  translate(x: number, y: number, z: number): InvertibleTransforms3D;\n\n  translate(x: Vector3D|number, y?: number, z?: number): InvertibleTransforms3D {\n    const vector = Vector3D.fromVectorOrCoords(x, y, z);\n\n    return this.addOp(\n      this.matrix.translate(vector),\n      m => m.translate(vector.times(-1))\n    );\n  }\n\n  /** Rotate counter-clockwise around the X axis. */\n  rotateX(radians: number) {\n    return this.addOp(\n      this.matrix.rotateX(radians),\n      m => m.rotateX(-radians)\n    );\n  }\n\n  /** Rotate counter-clockwise around the Y axis. */\n  rotateY(radians: number) {\n    return this.addOp(\n      this.matrix.rotateY(radians),\n      m => m.rotateY(-radians)\n    );\n  }\n\n  /** Rotate counter-clockwise around the Z axis. */\n  rotateZ(radians: number) {\n    return this.addOp(\n      this.matrix.rotateZ(radians),\n      m => m.rotateZ(-radians)\n    );\n  }\n\n  /** Return the inverse of the matrix. */\n  inverse(): Matrix3D {\n    let matrix = new Matrix3D();\n\n    for (let inverseOp of this.ops) {\n      matrix = inverseOp(matrix);\n    }\n\n    return matrix;\n  }\n}\n","import { Points3D } from \"./points-3d\";\nimport { Vector3D } from \"./vector-3d\";\nimport { Ray3D } from \"./ray-3d\";\nimport { Matrix3D } from \"./matrix-3d\";\n\nexport function makeSpaceship(): Points3D {\n  const leftHalf = Points3D.fromArray([\n    -0.5, 0, 0,\n    0, 0.75, 0,\n    0, 0.15, 0\n  ]);\n\n  return leftHalf.concat(leftHalf.mirrorHorizontally());\n}\n\nexport function makeGround(y = -1, xzStart = -1, size = 2, pointsPerAxis = 20): Points3D {\n  const points: number[] = [];\n  let xPart = xzStart;\n  let zPart = xzStart;\n  let partInc = 1 / pointsPerAxis;\n\n  for (let i = 0; i <= pointsPerAxis; i++) {\n    points.push(xPart, y, zPart);\n    points.push(xPart, y, zPart + size);\n    xPart += size * partInc;\n  }\n\n  xPart = xzStart;\n  for (let i = 0; i <= pointsPerAxis; i++) {\n    points.push(xPart, y, zPart);\n    points.push(xPart + size, y, zPart);\n    zPart += size * partInc;\n  }\n\n  return Points3D.fromArray(points);\n}\n\nexport function makeRayPoints(ray: Ray3D, segments = 10, length = 5): Points3D {\n  let point = ray.origin;\n  const increment = ray.direction.times(length / segments);\n  const points: number[] = [];\n\n  for (let i = 0; i < segments; i++) {\n    points.push(point.x, point.y, point.z);\n    point = point.plus(increment);\n    points.push(point.x, point.y, point.z);\n  }\n\n  return Points3D.fromArray(points);\n}\n\nexport function makeCircle(segments = 20): Points3D {\n  const points: number[] = [];\n  const start = new Vector3D(1, 0, 0);\n\n  for (let i = 0; i < segments; i++) {\n    const rotation = new Matrix3D().rotateZ(2 * Math.PI * (i / segments));\n    const p = rotation.transformVector(start);\n    points.push(p.x, p.y, p.z);\n  }\n\n  return Points3D.fromArray(points);\n}\n","import { Vector3D } from \"./vector-3d\";\n\nexport class Points3D {\n  constructor(private readonly array: Vector3D[]) {\n  }\n\n  toFloat32Array(): Float32Array {\n    const { array } = this;\n    const result = new Float32Array(array.length * 3);\n    let arrIndex = 0;\n\n    for (let i = 0; i < result.length; i += 3) {\n      result[i] = array[arrIndex].x;\n      result[i + 1] = array[arrIndex].y;\n      result[i + 2] = array[arrIndex].z;\n      arrIndex += 1;\n    }\n\n    return result;\n  }\n\n  concat(points: Points3D): Points3D {\n    const combined = this.array.concat(points.array);\n    return new Points3D(combined);\n  }\n\n  mirrorHorizontally(): Points3D {\n    return new Points3D(this.array.map(point => {\n      return new Vector3D(-point.x, point.y, point.z);\n    }));\n  }\n\n  get length(): number {\n    return this.array.length;\n  }\n\n  static fromArray(array: number[]|Float32Array) {\n    const numPoints = array.length / 3;\n    const pointArray = new Array<Vector3D>(numPoints);\n    let arrIndex = 0;\n    for (let i = 0; i < numPoints; i++) {\n      const x = array[arrIndex];\n      const y = array[arrIndex + 1];\n      const z = array[arrIndex + 2];\n      pointArray[i] = new Vector3D(x, y, z);\n      arrIndex += 3;\n    }\n    return new Points3D(pointArray);\n  }\n}\n","import { PerspectiveOptions, Matrix3D } from \"./matrix-3d\";\nimport { Vector3D } from \"./vector-3d\";\n\nexport type Point2D = {\n  x: number,\n  y: number\n};\n\nexport type Dimensions2D = {\n  width: number,\n  height: number\n};\n\n/**\n * Convert the given screen coordinates, in pixels, to\n * eye coordinates (from the perspective of the camera).\n */\nfunction screenCoordsToEye(canvas: Dimensions2D, point: Point2D, perspective: PerspectiveOptions): Vector3D {\n  const width = perspective.right - perspective.left;\n  const height = perspective.top - perspective.bottom;\n  const xPct = (point.x / canvas.width);\n  // Note that we need to flip the y-axis.\n  const yPct = ((canvas.height - point.y) / canvas.height);\n\n  const x = perspective.left + xPct * width;\n  const y = perspective.bottom + yPct * height;\n\n  // We need to flip the near value because it's specified in\n  // clip coordinates.\n  const z = -perspective.near;\n\n  return new Vector3D(x, y, z);\n}\n\n/**\n * Convert the given pixel coordinates on the given canvas to\n * points in the world.\n */\nexport function screenCoordsToWorld(\n  canvas: Dimensions2D,\n  point: Point2D,\n  perspective: PerspectiveOptions,\n  cameraTransform: Matrix3D\n): Vector3D {\n  const pointRelativeToCamera = screenCoordsToEye(canvas, point, perspective);\n  return cameraTransform.transformVector(pointRelativeToCamera);\n}\n","/**\n * Convenience class to store a value and detect\n * whether it has changed since the last time\n * we checked.\n */\nexport class CheckableValue<T> {\n  private lastCheckedValue: T|null = null;\n  private value: T|null = null;\n\n  /** Set the value. */\n  set(value: T) {\n    this.value = value;\n  }\n\n  /**\n   * If the value has changed since the last\n   * time we checked, pass it to the given callback\n   * function. Otherwise, do nothing.\n   */\n  check(cb: (value: T) => void) {\n    if (this.value === this.lastCheckedValue) {\n      return;\n    }\n    this.lastCheckedValue = this.value;\n    if (this.value) {\n      cb(this.value);\n    }\n  }\n}\n","import { Vector3D } from \"./vector-3d\";\n\n/**\n * An abstraction for a normalized ray that emanates\n * from an origin in a direction.\n */\nexport class Ray3D {\n  readonly direction: Vector3D;\n\n  constructor(readonly origin: Vector3D, direction: Vector3D) {\n    this.direction = direction.normalize();\n  }\n\n  pointAlong(t: number): Vector3D {\n    return this.origin.plus(this.direction.times(t));\n  }\n\n  static fromTo(from: Vector3D, to: Vector3D): Ray3D {\n    const direction = to.minus(from);\n    return new Ray3D(from, direction);\n  }\n}\n","import { Vector3D } from \"./vector-3d\";\nimport { Ray3D } from \"./ray-3d\";\n\n/**\n * Tests for ray/sphere intersection, returning null if the\n * ray never intersects with the sphere, or the vector\n * representing the closest point of intersection.\n * \n * Derivation for this can be found in Real-Time Rendering,\n * 4th edition, 22.6.1 (page 956).\n */\nexport function getRaySphereIntersection(ray: Ray3D, center: Vector3D, radius: number): null | Vector3D {\n  const originMinusCenter = ray.origin.minus(center);\n  const b = ray.direction.dot(originMinusCenter);\n  const c = originMinusCenter.dot(originMinusCenter) - radius * radius;\n  const bSquaredMinusC = b * b - c;\n\n  if (bSquaredMinusC < 0) {\n    return null;\n  }\n\n  const sqrt = Math.sqrt(bSquaredMinusC);\n  const t = [-b + sqrt, -b - sqrt].filter(value => value >= 0);\n  if (t.length === 0) {\n    return null;\n  }\n\n  const closestT = t.sort((a, b) => a - b)[0];\n  return ray.pointAlong(closestT);\n}\n","/**\n * Find an element.\n * \n * @param tagName The name of the element's HTML tag.\n * @param selector The selector for the element, not including its HTML tag.\n * @param parent The parent node to search within.\n */\nexport function getElement<K extends keyof HTMLElementTagNameMap>(\n  tagName: K,\n  selector: string,\n  parent: ParentNode = document\n): HTMLElementTagNameMap[K] {\n  const finalSelector = `${tagName}${selector}`;\n  const node = parent.querySelector(finalSelector);\n  if (!node) {\n    throw new Error(`Couldn't find any elements matching \"${finalSelector}\"`);\n  }\n  return node as HTMLElementTagNameMap[K];\n}\n","module.exports = \"attribute vec4 a_position;\\n\\nuniform mat4 u_transform;\\n\\nvoid main() {\\n  gl_Position = u_transform * a_position;\\n}\\n\";","module.exports = \"precision mediump float;\\n\\nvoid main() {\\n  // This essentially visualizes the z-buffer. Taken from:\\n  //\\n  //   https://learnopengl.com/Advanced-OpenGL/Depth-testing\\n  gl_FragColor = vec4(vec3(gl_FragCoord.z), 1.0);\\n}\\n\";"],"sourceRoot":""}