{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/vector-3d.ts","webpack:///./src/matrix-3d.ts","webpack:///./src/webgl.ts","webpack:///./src/app.ts","webpack:///./src/points-3d-renderer.ts","webpack:///./src/invertible-transforms-3d.ts","webpack:///./src/shapes.ts","webpack:///./src/points-3d.ts","webpack:///./src/screen-space.ts","webpack:///./src/ray-3d.ts","webpack:///./src/intersections.ts","webpack:///./src/get-element.ts","webpack:///./src/keyboard-map.ts","webpack:///./src/color.ts","webpack:///./src/simple-vertex-shader.glsl","webpack:///./src/simple-fragment-shader.glsl"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Vector3D","[object Object]","x","y","z","w","this","v","len","Math","sqrt","vector_3d_1","IDENTITY","Matrix3D","values","valueAt","Float32Array","row","column","fromVectorOrCoords","multiply","undefined","radians","cos","sin","m2","col1","transformVector","col2","col3","col4","f","map","options","near","far","left","right","top","bottom","width","height","depth","doubleNear","points","col","createShader","gl","type","source","shader","Error","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","msg","getShaderInfoLog","deleteShader","getAttribLocation","program","loc","GlProgram","vertexShaderSrc","fragmentShaderSrc","vertexShader","WebGLRenderingContext","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","useProgram","GlUniformBase","location","getUniformLocation","GlUniformVector3D","uniform4fv","GlUniformFloat","uniform1f","GlUniformMatrix3D","uniformMatrix4fv","toFloat32Array","GlUniformBoolean","setupBuffer","buffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","webgl_1","points_3d_renderer_1","matrix_3d_1","invertible_transforms_3d_1","shapes_1","screen_space_1","ray_3d_1","intersections_1","get_element_1","keyboard_map_1","color_1","simpleVertexShaderSrc","zBufferFragmentShaderSrc","DRAW_RAY","PURPLE","Color","fromHex","BLUE","SimpleGlProgram","super","projectionTransform","viewTransform","modelTransform","color","light","normal","shade","positionAttributeLocation","showZBuffer","Spaceship","state","colliderScale","transform","rotateZ","orbitTheta","translate","distanceFromCenter","scale","rotateY","shipTheta","props","random","orbitThetaVelocity","shipThetaVelocity","colliderRadius","ray","getRaySphereIntersection","center","CameraRay","cameraPosition","cameraTransform","matrix","screenPointInWorld","screenCoordsToWorld","canvas","coords","perspective","Ray3D","fromTo","makeRayPoints","renderer","Points3DRenderer","Scene","perspectiveProjection","InvertibleTransforms3D","cameraRotation","inverse","spaceships","ship","update","withColor","doesRayIntersect","window","addEventListener","ui","showColliders","getElement","pause","keyMap","KeyboardMap","setCheckboxToggler","buildUI","queuedActions","getContext","spaceshipRenderer","makeSpaceship","groundRenderer","makeGround","circleRenderer","makeCircle","e","checked","push","point","offsetX","offsetY","scene","viewport","enable","DEPTH_TEST","clearColor","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","activate","set","BLACK","setupForDrawing","draw","LINES","forEach","spaceship","getColliderTransform","baseModelTransform","modelTransformUniform","rotateX","PI","LINE_LOOP","drawCollider","action","shootRay","amount","createRandom","createRandomSpaceships","createInitialScene","updateFrame","render","actions","processAction","requestAnimationFrame","run","enableVertexAttribArray","FLOAT","vertexAttribPointer","primitiveType","TRIANGLES","count","length","drawArrays","ops","op","vector","addOp","times","inverseOp","points_3d_1","mirror","leftHalf","transformPoints","Points3D","fromArray","concat","xzStart","size","pointsPerAxis","xPart","zPart","partInc","segments","origin","increment","direction","plus","start","array","result","arrIndex","combined","fn","numPoints","pointArray","Array","pointRelativeToCamera","xPct","yPct","screenCoordsToEye","normalize","from","to","minus","radius","originMinusCenter","b","dot","bSquaredMinusC","filter","closestT","sort","a","pointAlong","tagName","selector","parent","document","finalSelector","node","querySelector","mapping","Map","body","handleEvent","el","kbd","createElement","textContent","appendChild","createTextNode","handler","toLowerCase","labelNode","addKbdElement","checkboxToggler","parentNode","red","green","blue","alpha","hex","slice","toFloat","parseInt","substr"],"mappings":"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","file":"app.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","/**\n * A three-dimensional vector. Note that it actually has\n * four elements because we use a homogeneous coordinate\n * system.\n */\nexport class Vector3D {\n  constructor(\n    readonly x: number = 0,\n    readonly y: number = 0,\n    readonly z: number = 0,\n    readonly w: number = 1.0\n  ) {}\n\n  perspectiveDivide(): Vector3D {\n    const { x, y, z, w } = this;\n    return new Vector3D(x / w, y / w, z / w);\n  }\n\n  minus(v: Vector3D): Vector3D {\n    const { x, y, z, w } = this;\n    return new Vector3D(x - v.x, y - v.y, z - v.z, w);\n  }\n\n  plus(v: Vector3D): Vector3D {\n    const { x, y, z, w } = this;\n    return new Vector3D(x + v.x, y + v.y, z + v.z, w);\n  }\n\n  times(n: number): Vector3D {\n    const { x, y, z, w } = this;\n    return new Vector3D(x * n, y * n, z * n, w);\n  }\n\n  dot(v: Vector3D): number {\n    const { x, y, z, w } = this;\n\n    return x * v.x + y * v.y + z * v.z;\n  }\n\n  normalize(): Vector3D {\n    const { x, y, z, w } = this;\n    const len = Math.sqrt(x * x + y * y + z * z);\n    return new Vector3D(x / len, y / len, z / len, w);\n  }\n\n  /**\n   * A helper to convert either a vector or a sequence of coordinates\n   * into a vector.\n   */\n  static fromVectorOrCoords(x: Vector3D | number, y?: number, z?: number): Vector3D {\n    z = x instanceof Vector3D ? x.z : z || 0;\n    y = x instanceof Vector3D ? x.y : y || 0;\n    x = x instanceof Vector3D ? x.x : x;\n    return new Vector3D(x, y, z);\n  }\n}","import { Vector3D } from \"./vector-3d\";\nimport { Points3D } from \"./points-3d\";\n\ntype Column = 1|2|3|4;\ntype Row = 1|2|3|4;\n\n/**\n * A 4x4 matrix represented as\n * a two-dimensional array in\n * row-major order.\n */\ntype Matrix3DTuple = [\n  [number, number, number, number],\n  [number, number, number, number],\n  [number, number, number, number],\n  [number, number, number, number]\n];\n\nexport type PerspectiveOptions = {\n  left: number;\n  right: number;\n  top: number;\n  bottom: number;\n  near: number;\n  far: number;\n};\n\nconst IDENTITY: Matrix3DTuple = [\n  [1, 0, 0, 0],\n  [0, 1, 0, 0],\n  [0, 0, 1, 0],\n  [0, 0, 0, 1]\n];\n\n/**\n * A three-dimensional matrix. Note that it ultimately represents a 4x4\n * matrix because we use homogeneous coordinates.\n */\nexport class Matrix3D {\n  constructor(readonly values: Matrix3DTuple = IDENTITY) {\n    this.valueAt = this.valueAt.bind(this);\n  }\n\n  /**\n   * Convert the matrix into a Float32Array in column-major order\n   * (the layout that GLSL expects).\n   */\n  toFloat32Array(): Float32Array {\n    const m = this.valueAt;\n    return new Float32Array([\n      m(1, 1), m(2, 1), m(3, 1), m(4, 1),\n      m(1, 2), m(2, 2), m(3, 2), m(4, 2),\n      m(1, 3), m(2, 3), m(3, 3), m(4, 3),\n      m(1, 4), m(2, 4), m(3, 4), m(4, 4),\n    ]);\n  }\n\n  valueAt(row: Row, column: Column): number {\n    return this.values[row - 1][column - 1];\n  }\n\n  translate(v: Vector3D): Matrix3D;\n  translate(x: number, y: number, z: number): Matrix3D;\n\n  translate(x: Vector3D|number, y?: number, z?: number): Matrix3D {\n    const v = Vector3D.fromVectorOrCoords(x, y, z);\n\n    return this.multiply(new Matrix3D([\n      [1, 0, 0, v.x],\n      [0, 1, 0, v.y],\n      [0, 0, 1, v.z],\n      [0, 0, 0,   1]\n    ]));\n  }\n\n  scale(x: number, y?: number, z?: number): Matrix3D {\n    if (y === undefined) {\n      y = x;\n    }\n    if (z === undefined) {\n      z = y;\n    }\n    return this.multiply(new Matrix3D([\n      [x, 0, 0, 0],\n      [0, y, 0, 0],\n      [0, 0, z, 0],\n      [0, 0, 0, 1]\n    ]));\n  }\n\n  /** Rotate counter-clockwise around the X axis. */\n  rotateX(radians: number) {\n    // Deriving this requires the trigonometric identities for angle sums:\n    //\n    //   https://en.wikipedia.org/wiki/List_of_trigonometric_identities\n    //\n    // That said, I think an alternative approach is to think of rotation\n    // as transformation of basis vectors via matrix multiplication,\n    // which simplifies things conceptually.\n    const c = Math.cos(radians);\n    const s = Math.sin(radians);\n    return this.multiply(new Matrix3D([\n      [1,  0, 0, 0],\n      [0,  c, s, 0],\n      [0, -s, c, 0],\n      [0,  0, 0, 1]\n    ]));\n  }\n\n  /** Rotate counter-clockwise around the Y axis. */\n  rotateY(radians: number) {\n    const c = Math.cos(radians);\n    const s = Math.sin(radians);\n    return this.multiply(new Matrix3D([\n      [c, 0, -s, 0],\n      [0, 1,  0, 0],\n      [s, 0,  c, 0],\n      [0, 0,  0, 1]\n    ]));\n  }\n\n  /** Rotate counter-clockwise around the Z axis. */\n  rotateZ(radians: number) {\n    const c = Math.cos(radians);\n    const s = Math.sin(radians);\n    return this.multiply(new Matrix3D([\n      [c, -s, 0, 0],\n      [s,  c, 0, 0],\n      [0,  0, 1, 0],\n      [0,  0, 0, 1]\n    ]));\n  }\n\n  multiply(m2: Matrix3D): Matrix3D {\n    // Conceptualy, it's easiest to think of matrix multiplication\n    // as a transformation of a coordinate system's basis\n    // vectors:\n    //\n    //   http://www.3blue1brown.com/essence-of-linear-algebra-page/\n    //\n    // This isn't particularly efficient code, but hopefully\n    // it is readable.\n    const col1 = this.transformVector(m2.column(1));\n    const col2 = this.transformVector(m2.column(2));\n    const col3 = this.transformVector(m2.column(3));\n    const col4 = this.transformVector(m2.column(4));\n    return new Matrix3D([\n      [col1.x, col2.x, col3.x, col4.x],\n      [col1.y, col2.y, col3.y, col4.y],\n      [col1.z, col2.z, col3.z, col4.z],\n      [col1.w, col2.w, col3.w, col4.w],\n    ]);\n  }\n\n  /**\n   * Apply the given function to every element of the matrix, returning\n   * a new one.\n   */\n  map(f: (value: number) => number): Matrix3D {\n    return new Matrix3D(this.values.map(row => row.map(f)) as Matrix3DTuple);\n  }\n\n  /**\n   * Multiply all elements of the matrix by the given constant,\n   * returning a new matrix.\n   */\n  multiplyByConstant(n: number): Matrix3D {\n    return this.map(value => value * n);\n  }\n\n  /**\n   * Create a matrix that transforms eye coordinates into clip\n   * coordinates.\n   * \n   * Note that clip coordinates will likely have a w-component\n   * that is not 1; the GPU will perform a perspective divide\n   * after the vertex shader to convert the clip coordinates\n   * into normalized device coordinates (NDC).\n   * \n   * Note also that the near and far parameters must be\n   * specified as positive numbers, as the clip coordinates\n   * use a left-handed coordinate system, while the\n   * eye coordinates use a right-handed coordinate system,\n   * and the projection matrix will convert between the\n   * two.\n   * \n   * For more details, as well as an excellent derivation\n   * of all the math behind all this, see:\n   * \n   *   http://www.songho.ca/opengl/gl_projectionmatrix.html#perspective\n   */\n  static perspectiveProjection(options: PerspectiveOptions): Matrix3D {\n    const { near, far, left, right, top, bottom } = options;\n    const width = right - left;\n    const height = top - bottom;\n    const depth = far - near;\n    const doubleNear = 2 * near;\n    return new Matrix3D([\n      [doubleNear / width, 0, (right + left) / width, 0],\n      [0, doubleNear / height, (top + bottom) / height, 0],\n      [0, 0, -(far + near) / depth, -2 * far * near / depth],\n      [0, 0, -1, 0]\n    ]);\n  }\n\n  transformPoints(points: Points3D): Points3D {\n    return points.map(v => this.transformVector(v));\n  }\n\n  transformVector(v: Vector3D): Vector3D {\n    const m = this.valueAt;\n    return new Vector3D(\n      m(1, 1) * v.x + m(1, 2) * v.y + m(1, 3) * v.z + m(1, 4) * v.w,\n      m(2, 1) * v.x + m(2, 2) * v.y + m(2, 3) * v.z + m(2, 4) * v.w,\n      m(3, 1) * v.x + m(3, 2) * v.y + m(3, 3) * v.z + m(3, 4) * v.w,\n      m(4, 1) * v.x + m(4, 2) * v.y + m(4, 3) * v.z + m(4, 4) * v.w,\n    );\n  }\n\n  column(col: Column): Vector3D {\n    const m = this.valueAt;\n    return new Vector3D(\n      m(1, col),\n      m(2, col),\n      m(3, col),\n      m(4, col)\n    );\n  }\n}\n","import { Matrix3D } from \"./matrix-3d\";\nimport { Vector3D } from \"./vector-3d\";\n\nfunction createShader(gl: WebGLRenderingContext, type: number, source: string): WebGLShader {\n  const shader = gl.createShader(type);\n  if (!shader) throw new Error(\"gl.createShader() failed!\");\n\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n  if (!success) {\n    const msg = \"Compiling shader failed: \" + gl.getShaderInfoLog(shader);\n    gl.deleteShader(shader);\n    throw new Error(msg);\n  }\n\n  return shader;\n}\n\nfunction createProgram(gl: WebGLRenderingContext, vertexShader: WebGLShader, fragmentShader: WebGLShader): WebGLProgram {\n  const program = gl.createProgram();\n  if (!program) throw new Error(\"gl.createProgram() failed!\");\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n\n  const success = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (!success) {\n    const msg = \"Linking program failed: \" + gl.getProgramInfoLog(program);\n    gl.deleteProgram(program);\n    throw new Error(msg);\n  }\n\n  return program;\n}\n\nfunction getUniformLocation(gl: WebGLRenderingContext, program: WebGLProgram, name: string): WebGLUniformLocation {\n  const loc = gl.getUniformLocation(program, name);\n\n  if (loc === null) {\n    throw new Error(`Unable to find uniform '${name}'!`);\n  }\n\n  return loc;\n}\n\nexport function getAttribLocation(gl: WebGLRenderingContext, program: WebGLProgram, name: string): number {\n  const loc = gl.getAttribLocation(program, name);\n\n  if (loc === -1) {\n    throw new Error(`Unable to find attribute '${name}'!`);\n  }\n\n  return loc;\n}\n\nexport class GlProgram {\n  readonly program: WebGLProgram;\n\n  constructor(readonly gl: WebGLRenderingContext, vertexShaderSrc: string, fragmentShaderSrc: string) {\n    const vertexShader = createShader(gl, WebGLRenderingContext.VERTEX_SHADER, vertexShaderSrc);\n    const fragmentShader = createShader(gl, WebGLRenderingContext.FRAGMENT_SHADER, fragmentShaderSrc);\n    this.program = createProgram(gl, vertexShader, fragmentShader);\n  }\n\n  activate() {\n    this.gl.useProgram(this.program);\n  }\n}\n\nclass GlUniformBase {\n  location: WebGLUniformLocation;\n\n  constructor(readonly program: GlProgram, name: string) {\n    this.location = getUniformLocation(program.gl, program.program, name);\n  }\n}\n\nexport class GlUniformVector3D extends GlUniformBase {\n  set(value: Vector3D) {\n    this.program.gl.uniform4fv(this.location, [value.x, value.y, value.z, value.w]);\n  }\n}\n\nexport class GlUniformFloat extends GlUniformBase {\n  set(value: number) {\n    this.program.gl.uniform1f(this.location, value);\n  }\n}\n\nexport class GlUniformMatrix3D extends GlUniformBase {\n  set(value: Matrix3D) {\n    this.program.gl.uniformMatrix4fv(this.location, false, value.toFloat32Array());\n  }\n}\n\nexport class GlUniformBoolean extends GlUniformBase {\n  set(value: boolean) {\n    this.program.gl.uniform1f(this.location, value ? 1 : 0);\n  }\n}\n\nexport function setupBuffer(gl: WebGLRenderingContext, value: Float32Array): WebGLBuffer {\n  const buffer = gl.createBuffer();\n\n  if (buffer === null) {\n    throw new Error(\"gl.createBuffer() failed!\");\n  }\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferData(gl.ARRAY_BUFFER, value, gl.STATIC_DRAW);\n\n  return buffer;\n}\n","import { GlProgram, getAttribLocation, GlUniformMatrix3D, GlUniformBoolean, GlUniformVector3D } from \"./webgl\";\nimport { Points3DRenderer, Points3DRendererProgram } from \"./points-3d-renderer\";\nimport { Matrix3D, PerspectiveOptions } from \"./matrix-3d\";\nimport { Vector3D } from \"./vector-3d\";\nimport { InvertibleTransforms3D } from \"./invertible-transforms-3d\";\nimport { makeSpaceship, makeGround, makeRayPoints, makeCircle } from \"./shapes\";\nimport { Point2D, screenCoordsToWorld, Dimensions2D } from \"./screen-space\";\nimport { Ray3D } from \"./ray-3d\";\nimport { getRaySphereIntersection } from \"./intersections\";\nimport { getElement } from \"./get-element\";\nimport { KeyboardMap } from \"./keyboard-map\";\nimport { Points3D } from \"./points-3d\";\nimport { BLACK, Color } from \"./color\";\n\nconst simpleVertexShaderSrc = require(\"./simple-vertex-shader.glsl\") as string;\nconst zBufferFragmentShaderSrc = require(\"./simple-fragment-shader.glsl\") as string;\n\nconst DRAW_RAY = false;\nconst PURPLE = Color.fromHex('#ed225d');\nconst BLUE = Color.fromHex('#2d7bb6');\n\nclass SimpleGlProgram extends GlProgram {\n  readonly projectionTransform: GlUniformMatrix3D;\n  readonly viewTransform: GlUniformMatrix3D;\n  readonly modelTransform: GlUniformMatrix3D;\n  readonly showZBuffer: GlUniformBoolean;\n  readonly color: GlUniformVector3D;\n  readonly light: GlUniformVector3D;\n  readonly normal: GlUniformVector3D;\n  readonly shade: GlUniformBoolean;\n  readonly positionAttributeLocation: number;\n\n  constructor(gl: WebGLRenderingContext) {\n    super(gl, simpleVertexShaderSrc, zBufferFragmentShaderSrc);\n    this.projectionTransform = new GlUniformMatrix3D(this, 'u_projection_transform');\n    this.viewTransform = new GlUniformMatrix3D(this, 'u_view_transform');\n    this.modelTransform = new GlUniformMatrix3D(this, 'u_model_transform');\n    this.color = new GlUniformVector3D(this, 'u_color');\n    this.light = new GlUniformVector3D(this, 'u_light');\n    this.normal = new GlUniformVector3D(this, 'u_normal');\n    this.shade = new GlUniformBoolean(this, 'u_shade');\n    this.positionAttributeLocation = getAttribLocation(gl, this.program, 'a_position');\n    this.showZBuffer = new GlUniformBoolean(this, 'u_show_z_buffer');\n  }\n}\n\ntype SpaceshipState = {\n  orbitTheta: number;\n  orbitThetaVelocity: number;\n  distanceFromCenter: number;\n  scale: number;\n  shipTheta: number;\n  shipThetaVelocity: number;\n  z: number;\n  color: Color;\n};\n\nclass Spaceship {\n  readonly state: Readonly<SpaceshipState>;\n\n  /** Model matrix to convert from object space to world space. */\n  readonly transform: Readonly<Matrix3D>;\n\n  /** The ship's surface normal, in object space. */\n  static readonly normal = new Vector3D(0, 0, 1);\n\n  private readonly colliderScale = 0.5;\n\n  constructor(state: SpaceshipState) {\n    this.state = state;\n\n    const transform = new Matrix3D()\n      .rotateZ(state.orbitTheta)\n      .translate(state.distanceFromCenter, 0, state.z)\n      .scale(state.scale)\n      .rotateY(state.shipTheta);\n\n    this.transform = transform;\n  }\n\n  static createRandom(props: Partial<SpaceshipState>) {\n    return new Spaceship({\n      orbitTheta: Math.random(),\n      orbitThetaVelocity: Math.random() * 0.01,\n      distanceFromCenter: Math.random(),\n      scale: 0.5,\n      shipTheta: Math.random(),\n      shipThetaVelocity: Math.random() * 0.05,\n      z: Math.random(),\n      color: PURPLE,\n      ...props\n    });\n  }\n\n  get colliderRadius(): number {\n    return this.state.scale * this.colliderScale;\n  }\n\n  /** Return a model matrix for the collider. */\n  getColliderTransform(): Matrix3D {\n    return this.transform.scale(this.colliderScale);\n  }\n\n  center(): Vector3D {\n    return this.transform.transformVector(new Vector3D());\n  }\n\n  doesRayIntersect(ray: Ray3D): boolean {\n    return getRaySphereIntersection(ray, this.center(), this.colliderRadius) !== null;\n  }\n\n  withColor(color: Color): Spaceship {\n    return new Spaceship({...this.state, color});\n  }\n\n  update(): Spaceship {\n    const { state } = this;\n    return new Spaceship({\n      ...state,\n      orbitTheta: state.orbitTheta + state.orbitThetaVelocity,\n      shipTheta: state.shipTheta + state.shipThetaVelocity,\n    });\n  }\n};\n\nfunction buildUI() {\n  const showColliders = getElement('input', '#show-colliders');\n  const pause = getElement('input', '#pause');\n  const showZBuffer = getElement('input', '#show-z-buffer');\n  const keyMap = new KeyboardMap();\n\n  keyMap.setCheckboxToggler('c', showColliders);\n  keyMap.setCheckboxToggler('p', pause);\n  keyMap.setCheckboxToggler('z', showZBuffer);\n\n  return {\n    showColliders,\n    pause,\n    showZBuffer\n  };\n}\n\nfunction drawCollider(baseModelTransform: Matrix3D,\n                      modelTransformUniform: GlUniformMatrix3D,\n                      renderer: Points3DRenderer) {\n  const modelTransforms = [\n    baseModelTransform,\n    baseModelTransform.rotateX(Math.PI / 2),\n    baseModelTransform.rotateY(Math.PI / 2)\n  ];\n\n  modelTransforms.forEach(transform => {\n    modelTransformUniform.set(transform);\n    renderer.draw(WebGLRenderingContext.LINE_LOOP);\n  });\n}\n\nclass CameraRay {\n  readonly ray: Ray3D;\n  readonly points: Points3D;\n  readonly renderer: Points3DRenderer;\n\n  constructor(options: {\n    program: Points3DRendererProgram,\n    cameraTransform: InvertibleTransforms3D,\n    canvas: Dimensions2D,\n    coords: Point2D,\n    perspective: PerspectiveOptions,\n  }) {\n    const cameraPosition = options.cameraTransform.matrix.transformVector(new Vector3D());\n    const screenPointInWorld = screenCoordsToWorld(\n      options.canvas,\n      options.coords,\n      options.perspective,\n      options.cameraTransform.matrix\n    );\n    this.ray = Ray3D.fromTo(cameraPosition, screenPointInWorld);\n    this.points = makeRayPoints(this.ray);\n    this.renderer = new Points3DRenderer(options.program, this.points);\n  }\n}\n\ntype SceneState = {\n  perspective: PerspectiveOptions;\n  spaceships: Spaceship[];\n  cameraRotation: number;\n  ray?: CameraRay;\n};\n\nclass Scene {\n  /** Matrix to convert from eye space to clip coordinates. */\n  readonly projectionTransform: Matrix3D;\n\n  /** Matrix to move the camera from the origin to its position in world space. */\n  readonly cameraTransform: InvertibleTransforms3D;\n\n  /** Matrix to convert from world space to eye space. */\n  readonly viewTransform: Matrix3D;\n\n  constructor(readonly state: Readonly<SceneState>) {\n    this.projectionTransform = Matrix3D.perspectiveProjection(state.perspective);\n    this.cameraTransform = new InvertibleTransforms3D()\n      .rotateY(state.cameraRotation)\n      .translate(0, 0, 2.25);\n    this.viewTransform = this.cameraTransform.inverse();\n  }\n\n  update(): Scene {\n    const { state } = this;\n    return new Scene({\n      ...state,\n      cameraRotation: state.cameraRotation + 0.001,\n      spaceships: state.spaceships.map(ship => ship.update())\n    });\n  }\n\n  shootRay(ray: CameraRay): Scene {\n    const { state } = this;\n    return new Scene({\n      ...state,\n      spaceships: state.spaceships.map(\n        s => s.withColor(s.doesRayIntersect(ray.ray) ? BLUE : PURPLE)\n      ),\n      ray\n    });\n  }\n};\n\nfunction createRandomSpaceships(amount = 30) {\n  const spaceships: Spaceship[] = [];\n\n  for (let i = 0; i < amount; i++) {\n    spaceships.push(Spaceship.createRandom({\n      z: -1 + ((i / amount) * 2)\n    }));\n  }\n\n  return spaceships;\n}\n\ntype ClickAction = {\n  type: 'click';\n  point: Point2D;\n};\n\ntype TickAction = {\n  type: 'tick'\n};\n\ntype AppAction = ClickAction|TickAction;\n\nclass App {\n  readonly ui = buildUI();\n  readonly gl: WebGLRenderingContext;\n  readonly program: SimpleGlProgram;\n  readonly spaceshipRenderer: Points3DRenderer;\n  readonly groundRenderer: Points3DRenderer;\n  readonly circleRenderer: Points3DRenderer;\n  private queuedActions: AppAction[] = [];\n\n  constructor(readonly canvas: HTMLCanvasElement) {\n    const gl = canvas.getContext('webgl');\n\n    if (!gl) throw new Error(\"webgl is not supported on this browser!\");\n\n    this.gl = gl;\n\n    const program = new SimpleGlProgram(gl);\n    this.program = program;\n    this.spaceshipRenderer = new Points3DRenderer(program, makeSpaceship());\n    this.groundRenderer = new Points3DRenderer(program, makeGround());\n    this.circleRenderer = new Points3DRenderer(program, makeCircle());\n\n    canvas.addEventListener('click', (e) => {\n      if (this.ui.pause.checked) return;\n      this.queuedActions.push({\n        type: 'click',\n        point: {x: e.offsetX, y: e.offsetY}\n      });\n    });\n  }\n\n  render(scene: Scene) {\n    const { gl, program } = this;\n\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n    gl.enable(gl.DEPTH_TEST);\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    program.activate();\n    program.showZBuffer.set(this.ui.showZBuffer.checked);\n    program.color.set(BLACK);\n    // Have the light be where the camera is.\n    program.light.set(scene.cameraTransform.matrix.transformVector(new Vector3D()));\n    program.projectionTransform.set(scene.projectionTransform);\n    program.viewTransform.set(scene.viewTransform);\n    program.shade.set(false);\n\n    if (scene.state.ray && DRAW_RAY) {\n      scene.state.ray.renderer.setupForDrawing();\n      // The ray is already in world coordinates.\n      program.modelTransform.set(new Matrix3D());\n      scene.state.ray.renderer.draw(gl.LINES);\n    }\n\n    this.groundRenderer.setupForDrawing();\n    // The ground is already in world coordinates.\n    program.modelTransform.set(new Matrix3D());\n    this.groundRenderer.draw(gl.LINES);\n\n    this.spaceshipRenderer.setupForDrawing();\n    program.shade.set(true);\n    program.normal.set(Spaceship.normal);\n    scene.state.spaceships.forEach(spaceship => {\n      program.color.set(spaceship.state.color);\n      program.modelTransform.set(spaceship.transform);\n      this.spaceshipRenderer.draw();\n    });\n    program.shade.set(false);\n\n    if (this.ui.showColliders.checked) {\n      this.circleRenderer.setupForDrawing();\n      scene.state.spaceships.forEach(spaceship => {\n        const transform = spaceship.getColliderTransform();\n        program.color.set(spaceship.state.color);\n        drawCollider(transform, program.modelTransform, this.circleRenderer);\n      });\n    }\n  }\n\n  processAction(scene: Scene, action: AppAction): Scene {\n    switch (action.type) {\n      case 'click':\n      return scene.shootRay(new CameraRay({\n        coords: action.point,\n        program: this.program,\n        canvas: this.canvas,\n        cameraTransform: scene.cameraTransform,\n        perspective: scene.state.perspective\n      }));\n\n      case 'tick':\n      return scene.update();\n    }\n  }\n\n  createInitialScene(): Scene {\n    return new Scene({\n      perspective: {\n        top: 1,\n        bottom: -1,\n        right: 1,\n        left: -1,\n        near: 1,\n        far: 4\n      },\n      spaceships: createRandomSpaceships(),\n      cameraRotation: 0\n    });\n  }\n\n  run() {\n    let scene = this.createInitialScene();\n\n    const updateFrame = () => {\n      this.render(scene);\n\n      const actions: AppAction[] = [...this.queuedActions];\n      this.queuedActions = [];\n\n      if (!this.ui.pause.checked) {\n        actions.push({ type: 'tick' });\n      }\n\n      for (let action of actions) {\n        scene = this.processAction(scene, action);\n      }\n\n      window.requestAnimationFrame(updateFrame);\n    }\n\n    updateFrame();\n  }\n}\n\nwindow.addEventListener('DOMContentLoaded', () => {\n  const app = new App(getElement('canvas', '#canvas'));\n\n  app.run();\n});\n","import { GlProgram, setupBuffer } from \"./webgl\";\nimport { Points3D } from \"./points-3d\";\n\nexport interface Points3DRendererProgram extends GlProgram {\n  positionAttributeLocation: number;\n}\n\nexport class Points3DRenderer {\n  buffer: WebGLBuffer;\n\n  constructor(readonly program: Points3DRendererProgram, readonly points: Points3D) {\n    const { gl } = program;\n    this.buffer = setupBuffer(gl, points.toFloat32Array());\n  }\n\n  setupForDrawing() {\n    const { gl, positionAttributeLocation } = this.program;\n\n    gl.enableVertexAttribArray(positionAttributeLocation);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n\n    const vertexSize = 3;\n    const type = gl.FLOAT;\n    const normalize = false;\n    const stride = 0;\n    const offset = 0;\n    gl.vertexAttribPointer(positionAttributeLocation, vertexSize, type, normalize, stride, offset);\n  }\n\n  draw(primitiveType: number = WebGLRenderingContext.TRIANGLES) {\n    const { gl } = this.program;\n    const drawOffset = 0;\n    const count = this.points.length;\n    gl.drawArrays(primitiveType, drawOffset, count);  \n  }\n}\n","import { Matrix3D } from \"./matrix-3d\";\nimport { Vector3D } from \"./vector-3d\";\n\ntype InvertOp = (m: Matrix3D) => Matrix3D;\n\n/**\n * A class that keeps track of simple 3D transformations made to it, so\n * its inverse can be easily computed.\n * \n * I originally thought this idea was too silly to use in practice, but\n * it's actually documented in Real-Time Rendering, 4th edition,\n * section 4.1.8 (page 69) as a perfectly valid way to invert many\n * kinds of matrices we're interested in.\n */\nexport class InvertibleTransforms3D {\n  constructor(readonly matrix: Matrix3D = new Matrix3D(), private ops: InvertOp[] = []) {\n  }\n\n  private addOp(matrix: Matrix3D, op: InvertOp): InvertibleTransforms3D {\n    return new InvertibleTransforms3D(matrix, [op, ...this.ops]);\n  }\n\n  translate(v: Vector3D): InvertibleTransforms3D;\n  translate(x: number, y: number, z: number): InvertibleTransforms3D;\n\n  translate(x: Vector3D|number, y?: number, z?: number): InvertibleTransforms3D {\n    const vector = Vector3D.fromVectorOrCoords(x, y, z);\n\n    return this.addOp(\n      this.matrix.translate(vector),\n      m => m.translate(vector.times(-1))\n    );\n  }\n\n  /** Rotate counter-clockwise around the X axis. */\n  rotateX(radians: number) {\n    return this.addOp(\n      this.matrix.rotateX(radians),\n      m => m.rotateX(-radians)\n    );\n  }\n\n  /** Rotate counter-clockwise around the Y axis. */\n  rotateY(radians: number) {\n    return this.addOp(\n      this.matrix.rotateY(radians),\n      m => m.rotateY(-radians)\n    );\n  }\n\n  /** Rotate counter-clockwise around the Z axis. */\n  rotateZ(radians: number) {\n    return this.addOp(\n      this.matrix.rotateZ(radians),\n      m => m.rotateZ(-radians)\n    );\n  }\n\n  /** Return the inverse of the matrix. */\n  inverse(): Matrix3D {\n    let matrix = new Matrix3D();\n\n    for (let inverseOp of this.ops) {\n      matrix = inverseOp(matrix);\n    }\n\n    return matrix;\n  }\n}\n","import { Points3D } from \"./points-3d\";\nimport { Vector3D } from \"./vector-3d\";\nimport { Ray3D } from \"./ray-3d\";\nimport { Matrix3D } from \"./matrix-3d\";\n\nexport function makeSpaceship(): Points3D {\n  const translate = new Matrix3D().translate(0, -0.25, 0);\n  const mirror = new Matrix3D().scale(-1, 1, 1);\n  const leftHalf = translate.transformPoints(Points3D.fromArray([\n    -0.5, 0, 0,\n    0, 0.75, 0,\n    0, 0.15, 0\n  ]));\n\n  return leftHalf.concat(mirror.transformPoints(leftHalf));\n}\n\nexport function makeGround(y = -1, xzStart = -1, size = 2, pointsPerAxis = 20): Points3D {\n  const points: number[] = [];\n  let xPart = xzStart;\n  let zPart = xzStart;\n  let partInc = 1 / pointsPerAxis;\n\n  for (let i = 0; i <= pointsPerAxis; i++) {\n    points.push(xPart, y, zPart);\n    points.push(xPart, y, zPart + size);\n    xPart += size * partInc;\n  }\n\n  xPart = xzStart;\n  for (let i = 0; i <= pointsPerAxis; i++) {\n    points.push(xPart, y, zPart);\n    points.push(xPart + size, y, zPart);\n    zPart += size * partInc;\n  }\n\n  return Points3D.fromArray(points);\n}\n\nexport function makeRayPoints(ray: Ray3D, segments = 1, length = 5): Points3D {\n  let point = ray.origin;\n  const increment = ray.direction.times(length / segments);\n  const points: number[] = [];\n\n  for (let i = 0; i < segments; i++) {\n    points.push(point.x, point.y, point.z);\n    point = point.plus(increment);\n    points.push(point.x, point.y, point.z);\n  }\n\n  return Points3D.fromArray(points);\n}\n\nexport function makeCircle(segments = 20): Points3D {\n  const points: number[] = [];\n  const start = new Vector3D(1, 0, 0);\n\n  for (let i = 0; i < segments; i++) {\n    const rotation = new Matrix3D().rotateZ(2 * Math.PI * (i / segments));\n    const p = rotation.transformVector(start);\n    points.push(p.x, p.y, p.z);\n  }\n\n  return Points3D.fromArray(points);\n}\n","import { Vector3D } from \"./vector-3d\";\n\nexport class Points3D {\n  constructor(private readonly array: Vector3D[]) {\n  }\n\n  toFloat32Array(): Float32Array {\n    const { array } = this;\n    const result = new Float32Array(array.length * 3);\n    let arrIndex = 0;\n\n    for (let i = 0; i < result.length; i += 3) {\n      result[i] = array[arrIndex].x;\n      result[i + 1] = array[arrIndex].y;\n      result[i + 2] = array[arrIndex].z;\n      arrIndex += 1;\n    }\n\n    return result;\n  }\n\n  concat(points: Points3D): Points3D {\n    const combined = this.array.concat(points.array);\n    return new Points3D(combined);\n  }\n\n  map(fn: (v: Vector3D) => Vector3D) {\n    return new Points3D(this.array.map(fn));\n  }\n\n  get length(): number {\n    return this.array.length;\n  }\n\n  static fromArray(array: number[]|Float32Array) {\n    const numPoints = array.length / 3;\n    const pointArray = new Array<Vector3D>(numPoints);\n    let arrIndex = 0;\n    for (let i = 0; i < numPoints; i++) {\n      const x = array[arrIndex];\n      const y = array[arrIndex + 1];\n      const z = array[arrIndex + 2];\n      pointArray[i] = new Vector3D(x, y, z);\n      arrIndex += 3;\n    }\n    return new Points3D(pointArray);\n  }\n}\n","import { PerspectiveOptions, Matrix3D } from \"./matrix-3d\";\nimport { Vector3D } from \"./vector-3d\";\n\nexport type Point2D = {\n  x: number,\n  y: number\n};\n\nexport type Dimensions2D = {\n  width: number,\n  height: number\n};\n\n/**\n * Convert the given screen coordinates, in pixels, to\n * eye coordinates (from the perspective of the camera).\n */\nfunction screenCoordsToEye(canvas: Dimensions2D, point: Point2D, perspective: PerspectiveOptions): Vector3D {\n  const width = perspective.right - perspective.left;\n  const height = perspective.top - perspective.bottom;\n  const xPct = (point.x / canvas.width);\n  // Note that we need to flip the y-axis.\n  const yPct = ((canvas.height - point.y) / canvas.height);\n\n  const x = perspective.left + xPct * width;\n  const y = perspective.bottom + yPct * height;\n\n  // We need to flip the near value because it's specified in\n  // clip coordinates.\n  const z = -perspective.near;\n\n  return new Vector3D(x, y, z);\n}\n\n/**\n * Convert the given pixel coordinates on the given canvas to\n * points in the world.\n */\nexport function screenCoordsToWorld(\n  canvas: Dimensions2D,\n  point: Point2D,\n  perspective: PerspectiveOptions,\n  cameraTransform: Matrix3D\n): Vector3D {\n  const pointRelativeToCamera = screenCoordsToEye(canvas, point, perspective);\n  return cameraTransform.transformVector(pointRelativeToCamera);\n}\n","import { Vector3D } from \"./vector-3d\";\n\n/**\n * An abstraction for a normalized ray that emanates\n * from an origin in a direction.\n */\nexport class Ray3D {\n  readonly direction: Vector3D;\n\n  constructor(readonly origin: Vector3D, direction: Vector3D) {\n    this.direction = direction.normalize();\n  }\n\n  pointAlong(t: number): Vector3D {\n    return this.origin.plus(this.direction.times(t));\n  }\n\n  static fromTo(from: Vector3D, to: Vector3D): Ray3D {\n    const direction = to.minus(from);\n    return new Ray3D(from, direction);\n  }\n}\n","import { Vector3D } from \"./vector-3d\";\nimport { Ray3D } from \"./ray-3d\";\n\n/**\n * Tests for ray/sphere intersection, returning null if the\n * ray never intersects with the sphere, or the vector\n * representing the closest point of intersection.\n * \n * Derivation for this can be found in Real-Time Rendering,\n * 4th edition, 22.6.1 (page 956).\n */\nexport function getRaySphereIntersection(ray: Ray3D, center: Vector3D, radius: number): null | Vector3D {\n  const originMinusCenter = ray.origin.minus(center);\n  const b = ray.direction.dot(originMinusCenter);\n  const c = originMinusCenter.dot(originMinusCenter) - radius * radius;\n  const bSquaredMinusC = b * b - c;\n\n  if (bSquaredMinusC < 0) {\n    return null;\n  }\n\n  const sqrt = Math.sqrt(bSquaredMinusC);\n  const t = [-b + sqrt, -b - sqrt].filter(value => value >= 0);\n  if (t.length === 0) {\n    return null;\n  }\n\n  const closestT = t.sort((a, b) => a - b)[0];\n  return ray.pointAlong(closestT);\n}\n","/**\n * Find an element.\n * \n * @param tagName The name of the element's HTML tag.\n * @param selector The selector for the element, not including its HTML tag.\n * @param parent The parent node to search within.\n */\nexport function getElement<K extends keyof HTMLElementTagNameMap>(\n  tagName: K,\n  selector: string,\n  parent: ParentNode = document\n): HTMLElementTagNameMap[K] {\n  const finalSelector = `${tagName}${selector}`;\n  const node = parent.querySelector(finalSelector);\n  if (!node) {\n    throw new Error(`Couldn't find any elements matching \"${finalSelector}\"`);\n  }\n  return node as HTMLElementTagNameMap[K];\n}\n","type KeyboardMapHandler = () => void;\n\nexport class KeyboardMap {\n  mapping: Map<string, KeyboardMapHandler> = new Map();\n\n  constructor() {\n    document.body.addEventListener('keypress', e => this.handleEvent(e));\n  }\n\n  private addKbdElement(key: string, el: Node) {\n    const kbd = document.createElement('kbd');\n    kbd.textContent = key;\n    el.appendChild(document.createTextNode(' '));\n    el.appendChild(kbd);\n  }\n\n  private handleEvent(e: KeyboardEvent) {\n    const handler = this.mapping.get(e.key.toLowerCase());\n    if (handler) {\n      handler();\n    }\n  }\n\n  set(key: string, handler: KeyboardMapHandler, labelNode?: Node|null) {\n    this.mapping.set(key, handler);\n    if (labelNode) {\n      this.addKbdElement(key, labelNode);\n    }\n  }\n\n  setCheckboxToggler(key: string, el: HTMLInputElement) {\n    this.set(key, checkboxToggler(el), el.parentNode);\n  }\n}\n\nfunction checkboxToggler(el: HTMLInputElement): KeyboardMapHandler {\n  return () => el.checked = !el.checked;\n}\n","import { Vector3D } from \"./vector-3d\";\n\nexport class Color extends Vector3D {\n  constructor(\n    red: number,\n    green: number,\n    blue: number,\n    alpha: number = 1.0  \n  ) {\n    super(red, green, blue, alpha);\n  }\n\n  static fromHex(hex: string): Color {\n    hex = hex.toLowerCase();\n\n    if (hex[0] == '#') {\n      hex = hex.slice(1);\n    }\n\n    const toFloat = (hex: string) => parseInt(hex, 16) / 255;\n\n    const red = toFloat(hex.substr(0, 2));\n    const green = toFloat(hex.substr(2, 2));\n    const blue = toFloat(hex.substr(4, 2));\n\n    return new Color(red, green, blue);\n  }\n}\n\nexport const BLACK = new Color(0, 0, 0);\n","module.exports = \"precision mediump float;\\n\\n/**\\n * Attributes\\n *\\n * These are passed into us and generally change\\n * from one execution of our shader program to the next\\n * during a render call.\\n */\\n\\n/** The position of the vertex, in object space. */\\nattribute vec4 a_position;\\n\\n/**\\n * Uniforms\\n *\\n * These are passed into us and do not change from\\n * one execution of our shader program to the next\\n * during a render call.\\n */\\n\\n/** The color of the vertex. */\\nuniform vec4 u_color;\\n\\n/** The vertex's normal in object space. */\\nuniform vec4 u_normal;\\n\\n/** The position of the light in world coordinates. */\\nuniform vec4 u_light;\\n\\n/**\\n * Whether or not to actually shade the vertex based on\\n * the current lighting.\\n */\\nuniform bool u_shade;\\n\\n/** Matrix to convert from eye space to clip coordinates. */\\nuniform mat4 u_projection_transform;\\n\\n/** Matrix to convert from world space to eye space. */\\nuniform mat4 u_view_transform;\\n\\n/** Matrix to convert from object space to world space. */\\nuniform mat4 u_model_transform;\\n\\n/**\\n * Varyings\\n *\\n * These are passed from us to the fragment shader.\\n */\\n\\n/** The color of the vertex. */\\nvarying vec4 v_color;\\n\\nvoid main() {\\n  gl_Position = u_projection_transform * u_view_transform * u_model_transform * a_position;\\n\\n  float light_amount = 1.0;\\n\\n  if (u_shade) {\\n    float ambient_light_amount = 0.25;\\n    float max_illumination = 1.0 - ambient_light_amount;\\n\\n    // The surface normal, in world space.\\n    vec4 world_normal = normalize(\\n      u_model_transform * u_normal -\\n      u_model_transform * vec4(0, 0, 0, 1)\\n    );\\n\\n    // The direction from the origin to the light source, in world space.\\n    vec4 world_light = normalize(u_light);\\n\\n    // Based on the angle between the surface normal and the\\n    // light, shade the vertex accordingly.\\n    //\\n    // Note that we're taking the absolute value of the dot\\n    // product because we're assuming that the shape we're\\n    // drawing is two-sided, and that the side of the shape\\n    // visible to the user is also the side that faces the\\n    // light.\\n    float illumination = abs(dot(world_normal, world_light));\\n\\n    light_amount = ambient_light_amount + illumination * max_illumination;\\n  }\\n\\n  v_color = vec4(light_amount * vec3(u_color), 1.0);\\n}\\n\";","module.exports = \"precision mediump float;\\n\\n/**\\n * Uniforms\\n *\\n * These are passed into us and do not change from\\n * one execution of our shader program to the next\\n * during a render call.\\n */\\n\\n/** Whether to color the fragment based on its z-buffer location. */\\nuniform bool u_show_z_buffer;\\n\\n/**\\n * Varyings\\n *\\n * These are passed into us from the vertex shader.\\n */\\n\\n/** The color of the fragment. */\\nvarying vec4 v_color;\\n\\nvoid main() {\\n  if (u_show_z_buffer) {\\n    // This essentially visualizes the z-buffer. Taken from:\\n    //\\n    //   https://learnopengl.com/Advanced-OpenGL/Depth-testing\\n    gl_FragColor = vec4(vec3(gl_FragCoord.z), 1.0);\\n  } else {\\n    gl_FragColor = v_color;\\n  }\\n}\\n\";"],"sourceRoot":""}