!function(t){var e={};function r(n){if(e[n])return e[n].exports;var o=e[n]={i:n,l:!1,exports:{}};return t[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=t,r.c=e,r.d=function(t,e,n){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var o in t)r.d(n,o,function(e){return t[e]}.bind(null,o));return n},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=3)}([function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class n{constructor(t=0,e=0,r=0,n=1){this.x=t,this.y=e,this.z=r,this.w=n}perspectiveDivide(){const{x:t,y:e,z:r,w:o}=this;return new n(t/o,e/o,r/o)}minus(t){const{x:e,y:r,z:o,w:s}=this;return new n(e-t.x,r-t.y,o-t.z,s)}plus(t){const{x:e,y:r,z:o,w:s}=this;return new n(e+t.x,r+t.y,o+t.z,s)}times(t){const{x:e,y:r,z:o,w:s}=this;return new n(e*t,r*t,o*t,s)}dot(t){const{x:e,y:r,z:n,w:o}=this;return e*t.x+r*t.y+n*t.z}normalize(){const{x:t,y:e,z:r,w:o}=this,s=Math.sqrt(t*t+e*e+r*r);return new n(t/s,e/s,r/s,o)}static fromVectorOrCoords(t,e,r){return r=t instanceof n?t.z:r||0,e=t instanceof n?t.y:e||0,t=t instanceof n?t.x:t,new n(t,e,r)}}e.Vector3D=n},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0),o=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];class s{constructor(t=o){this.values=t,this.valueAt=this.valueAt.bind(this)}toFloat32Array(){const t=this.valueAt;return new Float32Array([t(1,1),t(2,1),t(3,1),t(4,1),t(1,2),t(2,2),t(3,2),t(4,2),t(1,3),t(2,3),t(3,3),t(4,3),t(1,4),t(2,4),t(3,4),t(4,4)])}valueAt(t,e){return this.values[t-1][e-1]}translate(t,e,r){const o=n.Vector3D.fromVectorOrCoords(t,e,r);return this.multiply(new s([[1,0,0,o.x],[0,1,0,o.y],[0,0,1,o.z],[0,0,0,1]]))}scale(t,e,r){return void 0===e&&(e=t),void 0===r&&(r=e),this.multiply(new s([[t,0,0,0],[0,e,0,0],[0,0,r,0],[0,0,0,1]]))}rotateX(t){const e=Math.cos(t),r=Math.sin(t);return this.multiply(new s([[1,0,0,0],[0,e,r,0],[0,-r,e,0],[0,0,0,1]]))}rotateY(t){const e=Math.cos(t),r=Math.sin(t);return this.multiply(new s([[e,0,-r,0],[0,1,0,0],[r,0,e,0],[0,0,0,1]]))}rotateZ(t){const e=Math.cos(t),r=Math.sin(t);return this.multiply(new s([[e,-r,0,0],[r,e,0,0],[0,0,1,0],[0,0,0,1]]))}multiply(t){const e=this.transformVector(t.column(1)),r=this.transformVector(t.column(2)),n=this.transformVector(t.column(3)),o=this.transformVector(t.column(4));return new s([[e.x,r.x,n.x,o.x],[e.y,r.y,n.y,o.y],[e.z,r.z,n.z,o.z],[e.w,r.w,n.w,o.w]])}map(t){return new s(this.values.map(e=>e.map(t)))}multiplyByConstant(t){return this.map(e=>e*t)}static perspectiveProjection(t){const{near:e,far:r,left:n,right:o,top:a,bottom:i}=t,c=o-n,l=a-i,u=r-e,h=2*e;return new s([[h/c,0,(o+n)/c,0],[0,h/l,(a+i)/l,0],[0,0,-(r+e)/u,-2*r*e/u],[0,0,-1,0]])}transformPoints(t){return t.map(t=>this.transformVector(t))}transformVector(t){const e=this.valueAt;return new n.Vector3D(e(1,1)*t.x+e(1,2)*t.y+e(1,3)*t.z+e(1,4)*t.w,e(2,1)*t.x+e(2,2)*t.y+e(2,3)*t.z+e(2,4)*t.w,e(3,1)*t.x+e(3,2)*t.y+e(3,3)*t.z+e(3,4)*t.w,e(4,1)*t.x+e(4,2)*t.y+e(4,3)*t.z+e(4,4)*t.w)}column(t){const e=this.valueAt;return new n.Vector3D(e(1,t),e(2,t),e(3,t),e(4,t))}}e.Matrix3D=s},function(t,e,r){"use strict";function n(t,e,r){const n=t.createShader(e);if(!n)throw new Error("gl.createShader() failed!");if(t.shaderSource(n,r),t.compileShader(n),!t.getShaderParameter(n,t.COMPILE_STATUS)){const e="Compiling shader failed: "+t.getShaderInfoLog(n);throw t.deleteShader(n),new Error(e)}return n}Object.defineProperty(e,"__esModule",{value:!0}),e.getAttribLocation=function(t,e,r){const n=t.getAttribLocation(e,r);if(-1===n)throw new Error(`Unable to find attribute '${r}'!`);return n};e.GlProgram=class{constructor(t,e,r){this.gl=t;const o=n(t,WebGLRenderingContext.VERTEX_SHADER,e),s=n(t,WebGLRenderingContext.FRAGMENT_SHADER,r);this.program=function(t,e,r){const n=t.createProgram();if(!n)throw new Error("gl.createProgram() failed!");if(t.attachShader(n,e),t.attachShader(n,r),t.linkProgram(n),!t.getProgramParameter(n,t.LINK_STATUS)){const e="Linking program failed: "+t.getProgramInfoLog(n);throw t.deleteProgram(n),new Error(e)}return n}(t,o,s)}activate(){this.gl.useProgram(this.program)}};class o{constructor(t,e){this.program=t,this.location=function(t,e,r){const n=t.getUniformLocation(e,r);if(null===n)throw new Error(`Unable to find uniform '${r}'!`);return n}(t.gl,t.program,e)}}e.GlUniformVector3D=class extends o{set(t){this.program.gl.uniform4fv(this.location,[t.x,t.y,t.z,t.w])}};e.GlUniformFloat=class extends o{set(t){this.program.gl.uniform1f(this.location,t)}};e.GlUniformMatrix3D=class extends o{set(t){this.program.gl.uniformMatrix4fv(this.location,!1,t.toFloat32Array())}};e.GlUniformBoolean=class extends o{set(t){this.program.gl.uniform1f(this.location,t?1:0)}},e.setupBuffer=function(t,e){const r=t.createBuffer();if(null===r)throw new Error("gl.createBuffer() failed!");return t.bindBuffer(t.ARRAY_BUFFER,r),t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW),r}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(2),o=r(4),s=r(1),a=r(0),i=r(5),c=r(6),l=r(8),u=r(9),h=r(10),f=r(11),m=r(12),d=r(13),p=r(14),g=r(15),w=!1,y=d.Color.fromHex("#ed225d"),_=d.Color.fromHex("#2d7bb6");class v extends n.GlProgram{constructor(t){super(t,p,g),this.projectionTransform=new n.GlUniformMatrix3D(this,"u_projection_transform"),this.viewTransform=new n.GlUniformMatrix3D(this,"u_view_transform"),this.modelTransform=new n.GlUniformMatrix3D(this,"u_model_transform"),this.color=new n.GlUniformVector3D(this,"u_color"),this.light=new n.GlUniformVector3D(this,"u_light"),this.normal=new n.GlUniformVector3D(this,"u_normal"),this.shade=new n.GlUniformBoolean(this,"u_shade"),this.positionAttributeLocation=n.getAttribLocation(t,this.program,"a_position"),this.showZBuffer=new n.GlUniformBoolean(this,"u_show_z_buffer")}}class b{constructor(t){this.colliderScale=.5,this.state=t;const e=(new s.Matrix3D).rotateZ(t.orbitTheta).translate(t.distanceFromCenter,0,t.z).scale(t.scale).rotateY(t.shipTheta);this.transform=e}static createRandom(t){return new b({orbitTheta:Math.random(),orbitThetaVelocity:.01*Math.random(),distanceFromCenter:Math.random(),scale:.5,shipTheta:Math.random(),shipThetaVelocity:.05*Math.random(),z:Math.random(),color:y,...t})}get colliderRadius(){return this.state.scale*this.colliderScale}getColliderTransform(){return this.transform.scale(this.colliderScale)}center(){return this.transform.transformVector(new a.Vector3D)}doesRayIntersect(t){return null!==h.getRaySphereIntersection(t,this.center(),this.colliderRadius)}withColor(t){return new b({...this.state,color:t})}update(){const{state:t}=this;return new b({...t,orbitTheta:t.orbitTheta+t.orbitThetaVelocity,shipTheta:t.shipTheta+t.shipThetaVelocity})}}b.normal=new a.Vector3D(0,0,1);class x{constructor(t){const e=t.cameraTransform.matrix.transformVector(new a.Vector3D),r=l.screenCoordsToWorld(t.canvas,t.coords,t.perspective,t.cameraTransform.matrix);this.ray=u.Ray3D.fromTo(e,r),this.points=c.makeRayPoints(this.ray),this.renderer=new o.Points3DRenderer(t.program,this.points)}}class T{constructor(t){this.state=t,this.projectionTransform=s.Matrix3D.perspectiveProjection(t.perspective),this.cameraTransform=(new i.InvertibleTransforms3D).rotateY(t.cameraRotation).translate(0,0,2.25),this.viewTransform=this.cameraTransform.inverse()}update(){const{state:t}=this;return new T({...t,cameraRotation:t.cameraRotation+.001,spaceships:t.spaceships.map(t=>t.update())})}shootRay(t){const{state:e}=this;return new T({...e,spaceships:e.spaceships.map(e=>e.withColor(e.doesRayIntersect(t.ray)?_:y)),ray:t})}}window.addEventListener("DOMContentLoaded",()=>{new class{constructor(t){this.canvas=t,this.ui=function(){const t=f.getElement("input","#show-colliders"),e=f.getElement("input","#pause"),r=f.getElement("input","#show-z-buffer"),n=new m.KeyboardMap;return n.setCheckboxToggler("c",t),n.setCheckboxToggler("p",e),n.setCheckboxToggler("z",r),{showColliders:t,pause:e,showZBuffer:r}}(),this.queuedActions=[];const e=t.getContext("webgl");if(!e)throw new Error("webgl is not supported on this browser!");this.gl=e;const r=new v(e);this.program=r,this.spaceshipRenderer=new o.Points3DRenderer(r,c.makeSpaceship()),this.groundRenderer=new o.Points3DRenderer(r,c.makeGround()),this.circleRenderer=new o.Points3DRenderer(r,c.makeCircle()),t.addEventListener("click",t=>{this.ui.pause.checked||this.queuedActions.push({type:"click",point:{x:t.offsetX,y:t.offsetY}})})}render(t){const{gl:e,program:r}=this;e.viewport(0,0,e.canvas.width,e.canvas.height),e.enable(e.DEPTH_TEST),e.clearColor(0,0,0,0),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT),r.activate(),r.showZBuffer.set(this.ui.showZBuffer.checked),r.color.set(d.BLACK),r.light.set(t.cameraTransform.matrix.transformVector(new a.Vector3D)),r.projectionTransform.set(t.projectionTransform),r.viewTransform.set(t.viewTransform),r.shade.set(!1),t.state.ray&&w&&(t.state.ray.renderer.setupForDrawing(),r.modelTransform.set(new s.Matrix3D),t.state.ray.renderer.draw(e.LINES)),this.groundRenderer.setupForDrawing(),r.modelTransform.set(new s.Matrix3D),this.groundRenderer.draw(e.LINES),this.spaceshipRenderer.setupForDrawing(),r.shade.set(!0),r.normal.set(b.normal),t.state.spaceships.forEach(t=>{r.color.set(t.state.color),r.modelTransform.set(t.transform),this.spaceshipRenderer.draw()}),r.shade.set(!1),this.ui.showColliders.checked&&(this.circleRenderer.setupForDrawing(),t.state.spaceships.forEach(t=>{const e=t.getColliderTransform();r.color.set(t.state.color),function(t,e,r){[t,t.rotateX(Math.PI/2),t.rotateY(Math.PI/2)].forEach(t=>{e.set(t),r.draw(WebGLRenderingContext.LINE_LOOP)})}(e,r.modelTransform,this.circleRenderer)}))}processAction(t,e){switch(e.type){case"click":return t.shootRay(new x({coords:e.point,program:this.program,canvas:this.canvas,cameraTransform:t.cameraTransform,perspective:t.state.perspective}));case"tick":return t.update()}}createInitialScene(){return new T({perspective:{top:1,bottom:-1,right:1,left:-1,near:1,far:4},spaceships:function(t=30){const e=[];for(let r=0;r<t;r++)e.push(b.createRandom({z:r/t*2-1}));return e}(),cameraRotation:0})}run(){let t=this.createInitialScene();const e=()=>{this.render(t);const r=[...this.queuedActions];this.queuedActions=[],this.ui.pause.checked||r.push({type:"tick"});for(let e of r)t=this.processAction(t,e);window.requestAnimationFrame(e)};e()}}(f.getElement("canvas","#canvas")).run()})},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(2);e.Points3DRenderer=class{constructor(t,e){this.program=t,this.points=e;const{gl:r}=t;this.buffer=n.setupBuffer(r,e.toFloat32Array())}setupForDrawing(){const{gl:t,positionAttributeLocation:e}=this.program;t.enableVertexAttribArray(e),t.bindBuffer(t.ARRAY_BUFFER,this.buffer);const r=t.FLOAT;t.vertexAttribPointer(e,3,r,!1,0,0)}draw(t=WebGLRenderingContext.TRIANGLES){const{gl:e}=this.program,r=this.points.length;e.drawArrays(t,0,r)}}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(1),o=r(0);class s{constructor(t=new n.Matrix3D,e=[]){this.matrix=t,this.ops=e}addOp(t,e){return new s(t,[e,...this.ops])}translate(t,e,r){const n=o.Vector3D.fromVectorOrCoords(t,e,r);return this.addOp(this.matrix.translate(n),t=>t.translate(n.times(-1)))}rotateX(t){return this.addOp(this.matrix.rotateX(t),e=>e.rotateX(-t))}rotateY(t){return this.addOp(this.matrix.rotateY(t),e=>e.rotateY(-t))}rotateZ(t){return this.addOp(this.matrix.rotateZ(t),e=>e.rotateZ(-t))}inverse(){let t=new n.Matrix3D;for(let e of this.ops)t=e(t);return t}}e.InvertibleTransforms3D=s},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(7),o=r(0),s=r(1);e.makeSpaceship=function(){const t=(new s.Matrix3D).translate(0,-.25,0),e=(new s.Matrix3D).scale(-1,1,1),r=t.transformPoints(n.Points3D.fromArray([-.5,0,0,0,.75,0,0,.15,0]));return r.concat(e.transformPoints(r))},e.makeGround=function(t=-1,e=-1,r=2,o=20){const s=[];let a=e,i=e,c=1/o;for(let e=0;e<=o;e++)s.push(a,t,i),s.push(a,t,i+r),a+=r*c;a=e;for(let e=0;e<=o;e++)s.push(a,t,i),s.push(a+r,t,i),i+=r*c;return n.Points3D.fromArray(s)},e.makeRayPoints=function(t,e=1,r=5){let o=t.origin;const s=t.direction.times(r/e),a=[];for(let t=0;t<e;t++)a.push(o.x,o.y,o.z),o=o.plus(s),a.push(o.x,o.y,o.z);return n.Points3D.fromArray(a)},e.makeCircle=function(t=20){const e=[],r=new o.Vector3D(1,0,0);for(let n=0;n<t;n++){const o=(new s.Matrix3D).rotateZ(2*Math.PI*(n/t)).transformVector(r);e.push(o.x,o.y,o.z)}return n.Points3D.fromArray(e)}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0);class o{constructor(t){this.array=t}toFloat32Array(){const{array:t}=this,e=new Float32Array(3*t.length);let r=0;for(let n=0;n<e.length;n+=3)e[n]=t[r].x,e[n+1]=t[r].y,e[n+2]=t[r].z,r+=1;return e}concat(t){const e=this.array.concat(t.array);return new o(e)}map(t){return new o(this.array.map(t))}get length(){return this.array.length}static fromArray(t){const e=t.length/3,r=new Array(e);let s=0;for(let o=0;o<e;o++){const e=t[s],a=t[s+1],i=t[s+2];r[o]=new n.Vector3D(e,a,i),s+=3}return new o(r)}}e.Points3D=o},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0);e.screenCoordsToWorld=function(t,e,r,o){const s=function(t,e,r){const o=r.right-r.left,s=r.top-r.bottom,a=e.x/t.width,i=(t.height-e.y)/t.height,c=r.left+a*o,l=r.bottom+i*s,u=-r.near;return new n.Vector3D(c,l,u)}(t,e,r);return o.transformVector(s)}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class n{constructor(t,e){this.origin=t,this.direction=e.normalize()}pointAlong(t){return this.origin.plus(this.direction.times(t))}static fromTo(t,e){const r=e.minus(t);return new n(t,r)}}e.Ray3D=n},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getRaySphereIntersection=function(t,e,r){const n=t.origin.minus(e),o=t.direction.dot(n),s=o*o-(n.dot(n)-r*r);if(s<0)return null;const a=Math.sqrt(s),i=[-o+a,-o-a].filter(t=>t>=0);if(0===i.length)return null;const c=i.sort((t,e)=>t-e)[0];return t.pointAlong(c)}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getElement=function(t,e,r=document){const n=`${t}${e}`,o=r.querySelector(n);if(!o)throw new Error(`Couldn't find any elements matching "${n}"`);return o}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.KeyboardMap=class{constructor(){this.mapping=new Map,document.body.addEventListener("keypress",t=>this.handleEvent(t))}addKbdElement(t,e){const r=document.createElement("kbd");r.textContent=t,e.appendChild(document.createTextNode(" ")),e.appendChild(r)}handleEvent(t){const e=this.mapping.get(t.key.toLowerCase());e&&e()}set(t,e,r){this.mapping.set(t,e),r&&this.addKbdElement(t,r)}setCheckboxToggler(t,e){this.set(t,function(t){return()=>t.checked=!t.checked}(e),e.parentNode)}}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=r(0);class o extends n.Vector3D{constructor(t,e,r,n=1){super(t,e,r,n)}static fromHex(t){"#"==(t=t.toLowerCase())[0]&&(t=t.slice(1));const e=t=>parseInt(t,16)/255,r=e(t.substr(0,2)),n=e(t.substr(2,2)),s=e(t.substr(4,2));return new o(r,n,s)}}e.Color=o,e.BLACK=new o(0,0,0)},function(t,e){t.exports="precision mediump float;\n\n/**\n * Attributes\n *\n * These are passed into us and generally change\n * from one execution of our shader program to the next\n * during a render call.\n */\n\n/** The position of the vertex, in object space. */\nattribute vec4 a_position;\n\n/**\n * Uniforms\n *\n * These are passed into us and do not change from\n * one execution of our shader program to the next\n * during a render call.\n */\n\n/** The color of the vertex. */\nuniform vec4 u_color;\n\n/** The vertex's normal in object space. */\nuniform vec4 u_normal;\n\n/** The position of the light in world coordinates. */\nuniform vec4 u_light;\n\n/**\n * Whether or not to actually shade the vertex based on\n * the current lighting.\n */\nuniform bool u_shade;\n\n/** Matrix to convert from eye space to clip coordinates. */\nuniform mat4 u_projection_transform;\n\n/** Matrix to convert from world space to eye space. */\nuniform mat4 u_view_transform;\n\n/** Matrix to convert from object space to world space. */\nuniform mat4 u_model_transform;\n\n/**\n * Varyings\n *\n * These are passed from us to the fragment shader.\n */\n\n/** The color of the vertex. */\nvarying vec4 v_color;\n\nvoid main() {\n  gl_Position = u_projection_transform * u_view_transform * u_model_transform * a_position;\n\n  float light_amount = 1.0;\n\n  if (u_shade) {\n    float ambient_light_amount = 0.25;\n    float max_illumination = 1.0 - ambient_light_amount;\n\n    // The surface normal, in world space.\n    vec4 world_normal = normalize(\n      u_model_transform * u_normal -\n      u_model_transform * vec4(0, 0, 0, 1)\n    );\n\n    // The direction from the origin to the light source, in world space.\n    vec4 world_light = normalize(u_light);\n\n    // Based on the angle between the surface normal and the\n    // light, shade the vertex accordingly.\n    //\n    // Note that we're taking the absolute value of the dot\n    // product because we're assuming that the shape we're\n    // drawing is two-sided, and that the side of the shape\n    // visible to the user is also the side that faces the\n    // light.\n    float illumination = abs(dot(world_normal, world_light));\n\n    light_amount = ambient_light_amount + illumination * max_illumination;\n  }\n\n  v_color = vec4(light_amount * vec3(u_color), 1.0);\n}\n"},function(t,e){t.exports="precision mediump float;\n\n/**\n * Uniforms\n *\n * These are passed into us and do not change from\n * one execution of our shader program to the next\n * during a render call.\n */\n\n/** Whether to color the fragment based on its z-buffer location. */\nuniform bool u_show_z_buffer;\n\n/**\n * Varyings\n *\n * These are passed into us from the vertex shader.\n */\n\n/** The color of the fragment. */\nvarying vec4 v_color;\n\nvoid main() {\n  if (u_show_z_buffer) {\n    // This essentially visualizes the z-buffer. Taken from:\n    //\n    //   https://learnopengl.com/Advanced-OpenGL/Depth-testing\n    gl_FragColor = vec4(vec3(gl_FragCoord.z), 1.0);\n  } else {\n    gl_FragColor = v_color;\n  }\n}\n"}]);
//# sourceMappingURL=app.bundle.js.map